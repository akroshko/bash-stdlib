#!/bin/bash
# bash_functions_common is a set of bash functions for non-specific
# functionality.
#
# Copyright (C) 2015-2019, Andrew Kroshko, all rights reserved.
#
# Author: Andrew Kroshko
# Maintainer: Andrew Kroshko <akroshko.public+devel@gmail.com>
# Created: Fri Mar 27, 2015
# Version: 20190409
# URL: https://github.com/akroshko/cic-bash-common
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

need_new_directory () {
    # create a new directory if it does not already exist
    mkdir -p "$1"
}

verify-operation () {
    # this function verifies a deletion and asks twice to make sure,
    # generally used to ensure an operation is successful before
    # deleting
    local ASKMESSAGE="$1"
    local SUREMESSAGE="$2"
    local RMARG="$3"
    while true; do
        while read -r -t 0;do read -r; done
        read -n 1 -p "$ASKMESSAGE" YN
        echo ""
        case $YN in
            # TODO: make a bit more general so I can select a command
            [Yy]* ) (home-trash "$RMARG"); break;;
            # are you sure you don't want to delete original
            [Nn]* )
                while read -r -t 0;do read -r; done
                read -p "$SUREMESSAGE" YNT
                case $YNT in
                    [Yy]* ) return 0;;
                    [Nn]* ) true;;
                    * ) warn "Try again!"
                esac
                ;;
            * ) warn "Please answer yes or no.";;
        esac
    done
}

home-trash () {
    # delete by moving to a trash file that can be periodically
    # checked
    local TRASHFILE="$1"
    mkdir -p "$HOME/tmp/trash"
    \mv --backup=t -- "$TRASHFILE" "$HOME/tmp/trash"
}

date-time-stamp () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%d%H%M%S)
}

date-time-stamp-t () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%dt%H%M%S)
}

date-stamp () {
    # a date stamp with just the date
    echo $(date +%Y%m%d)
}

memory-log () {
    # log memory, used for long running experiments that might crash a computer
    while true; do
        { cat /proc/meminfo | sed -n 2p ; date ; } | tr "\n" " "
        echo ""
        sleep 30;
    done >> "$HOME/memory-$(date +%Y%m%d%H%M%S).log"
}

ag-show () {
    # show details of a Debian package
    apt-cache show "$1"
}
# XXXX: only different when using bash completion
alias ag-show-installed=ag-show

ag-search () {
    # search for a Debian package
    # TODO: search multiple terms?
    apt-cache search "$1"
}

ag-install () {
    # TODO: check if already installed
    # TODO: no sudo for dry run??? abort if can't sudo?
    # TODO: check if apt-get update needed
    apt-get install --dry-run "$@"
    echo "Do install for real?"
    # install a Debian package
    if ask_yn "Install?";  then
        sudo apt-get install "$@"
    else
        msg "Aborting!"
    fi
}

ag-install-dry-run () {
    # just a dry run to install a Debian package
    apt-get install --dry-run "$@"
}

ag-remove () {
    # uninstall a Debian package
    sudo apt-get remove "$@"
}

ag-list () {
    # list files installed by a Debian package
    dpkg-query -L "$1"
}

# TODO: search multiple terms?
ag-list-installed () {
    if [[ -z "$1" ]]; then
        dpkg-query -l
    else
        dpkg-query -l | grep -- "$1"
    fi
}

# TODO: see if I can use aes256-gcm@openssh.com for everything

ssh-batch () {
    # run ssh in batch mode
    ssh -o "BatchMode yes" "$@"
}

ssh-batch-lan () {
    # run ssh in batch mode but use no compression
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" "$@"
}

ssh-batch-interact () {
    # run ssh in batch mode but allow interaction with the resulting terminal
    ssh -o "BatchMode yes" -t "$@"
}

ssh-batch-interact-lan () {
    # run ssh in batch mode but allow interaction with the resulting terminal
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" -t "$@"
}

ssh-lan () {
    # run ssh with no compression
    ssh -o "Compression no" "$@"
}

scp-lan () {
    # run scp with no compression
    scp -o "Compression no" "$@"
}

sftp-lan () {
    # use sftp with no compression
    sftp -o "Compression no" "$@"
}

alias ssh-x11='sshx'
sshx () {
    # ssh with X11 forwarding enabled
    ssh -X -o "Compression yes" "$@"
}

sshnox () {
    # ssh with X11 forwarding explicitly disabled
    ssh -o "ForwardX11 no" "$@"
}

alias ssh-x11-lan='sshx-lan'
sshx-lan () {
    # ssh with X11 forwarding and compression explicitly disabled
    ssh -X -o "Compression no" "$@"
}

autossh-tunnel () {
    # set up a tunnel using autossh
    autossh -M 0 -o "BatchMode yes" -o "Compression yes" -N "$@"
}

autossh-tunnel-lan () {
    # set up a tunnel using autossh, compression off best for lan
    autossh -M 0 -o "BatchMode yes" -o "Compression no" -N "$@"
}

transform-resize-web () {
    # resize photos to a nice size for the web
    # TODO: change the prefix name?
    convert "$1" -resize 1200x800 "resize_$1"
}

transform-ffmpeg-mp3 () {
    # convert any media file to an mp3 using ffmpeg
    ffmpeg -i "$1" -f mp3 "${1%.*}.mp3"
}

transform-rotate-right () {
    # rotate a photo right 90 degrees
    convert "$1" -rotate 90 "rotate_$1"
}

transform-rotate-180 () {
    # flip a photo 180 degrees
    convert "$1" -rotate 180 "rotate_$1"
}

transform-rotate-left () {
    # rotate a photo left 90 degrees
    convert "$1" -rotate 270 "rotate_$1"
}

serve-here () {
    # serve the current directory here on port 8080
    ifconfig
    python -m SimpleHTTPServer 8080
}

nmap-network () {
    # use nmap to show network interfaces
    nmap --iflist
}

nmap-host-ports () {
    # show ports open on a host
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time nmap -v -sT -p 1-65535 "$1"
}

nmap-host-ports-super () {
    # really slowly look for ports open on a host
    sudo true || { echo "Failed to sudo!"; return 1; }
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time sudo nmap -v -sS -p 1-65535 "$1"
}

nmap-lan () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time nmap -sP 192.168.0-1.0-255
}

nmap-lan-os () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # generally takes less than a minute
    time sudo nmap -sS -O 192.168.0-1.0-255
}

nmap-lan-super () {
    # scan current network, based on common home router addresses,
    # slowly using nmap
    # generally takes less than 10 minutes, or less than 10 seconds
    time sudo nmap -sS 192.168.0-1.0-255
}

nmap-lan-complete () {
    # scan current network completely using nmap
    time sudo nmap -sP 192.168.0.0/16
}

nmap-lan-complete-super () {
    # scan current network completely and slowly using nmap
    time sudo nmap -sS 192.168.0.0/16
}

netstat-connections () {
    # check current networking connections
    netstat --udp --tcp --all --numeric --programs
}

netstat-connections-super () {
    # check current networking connections
    sudo netstat -untap
}

lpr-double-sided-portrait () {
    # print file as double-sided in portrait mode
    # TODO:
    lpr -o sides=two-sided-long-edge "$1"
}

lpr-double-sided-landscape () {
    # print file as double-sided in landscape mode
    # TODO:
    lpr -o sides=two-sided-short-edge "$1"
}

ls-sort-date () {
    # ls and sort by reverse date
    ls -ltr
}

need_new_symlink () {
    # create new symlink deleting old symlinks but not old files
    if [[ -e "$2" && ! -h "$2" ]]; then
        # symlink is a file or something
        yell "$2: exists but is not a symlink!!!"
    elif [[ ! -h "$2" ]]; then
        # symlink does not exist at all or is a file
        ln -s "$1" "$2"
    elif [[ -h "$2" && ! -e "$2" ]]; then
        # symlink exists but is invalid
        rm -f "$2"
        ln -s "$1" "$2"
    elif [[ -h "$2" && $(readlink -f -- "$2") != $(readlink -f -- "$1") ]]; then
        # symlink exists but points to different location than we are going to
        yell "Symlink $2 exists but points to $(readlink -f -- "$2") instead of $1!"
    fi
}

need_new_symlink_touch () {
    # create a new symlink but touch the target first to ensure it exists
    touch "$1"
    need_new_symlink "$1" "$2"
}


cp_if_different () {
    # copy files only if they are different
    local FOUNDDIFFERENT=1
    # is destination a directory
    if [[ -d "$2" ]]; then
        local THEBASENAME=$(basename -- "$1")
        if ! cmp --silent "$1" "$2"/"$THEBASENAME"; then
            command cp "$1" "$2"
            FOUNDDIFFERENT=0
        fi
    else
        if [[ ! -e "$2" ]] || ! cmp --silent "$1" "$2"; then
            command cp "$1" "$2"
            FOUNDDIFFERENT=0
        fi
    fi
    return $FOUNDDIFFERENT
}

match_string_array () {
    # check if a given string is in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do
        [[ "$e" =~ "$1" ]] && return 0
    done
    return 1
}

not_match_string_array () {
    # check if a given string is not in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do
        [[ "$e" =~ "$1" ]] && return 1
    done
    return 0
}

view-def () {
    # view the definition of a bash function
    # TODO: what if I have something as both alias and bash function
    # TODO: avoid double run
    if declare -f "$1" 2>&1 >/dev/null; then
        h1 "Bash function definition"
        declare -f "$1"
    fi
    if alias | grep -- '^alias \([A-Za-z0-9_-]*'"$1"'[A-Za-z0-9_-]*\)=' 2>&1 >/dev/null; then
       h1 "Alias definition"
       alias | grep -- '^alias \([A-Za-z0-9_-]*'"$1"'[A-Za-z0-9_-]*\)='
    fi
}

read-file-regexp () {
    # read lines from a file and merge them into a regexp
    local NEWREGEXP=""
    while read line; do
        NEWREGEXP+=$line"|"
    done < "$1"
    echo ${NEWREGEXP::-1}
}

clean-pwd-files-pretend () {
    # see if files in current directory can be renamed to be safe from
    # punctuation and unicode boogeymen
    rename -n "s|'||g" *
    rename -n "s|:||g" *
    rename -n "s|\xe2\x80\x99||g" *
    rename -n "s|\xe2\x80\x93|-|g" *
    rename -n "s|\xe2\x80\x94|-|g" *
    rename -n "s|\xc2\xa1|-|g" *
}

clean-pwd-files () {
    # actually rename files in current directory to be safe from
    # punctuation and unicode boogeymen
    rename "s|'||g" *
    rename "s|:||g" *
    rename "s|\xe2\x80\x99||g" *
    rename "s|\xe2\x80\x93|-|g" *
    rename "s|\xe2\x80\x94|-|g" *
    rename "s|\xc2\xa1|i|g" *
}

psg () {
    # grep process
    if [[ -z "$1" ]]; then
        ps -efj | less
    else
        # TODO: this can be done better!
        ps -efj | head -n 1
        ps -efj | grep -- "$1"
    fi
}

cpu-throttle-up () {
    # throttle up all CPUs
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "$i" -g performance
    done
}

cpu-throttle-ondemand () {
    # set all CPUs to ondemand
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "$i" -g ondemand
    done
}

cpu-throttle-down () {
    # throttle down all CPUs
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "$i" -g powersave
    done
}

find-broken-symlinks () {
    # find- for useful find command variations
    find . -type l -xtype l
}

xclip-show-all () {
    # show contents of X11 primary, secondary, and clipboard
    h1
    msg "Primary"
    xclip -o -selection p
    echo ""
    h1
    msg "Secondary"
    xclip -o -selection s
    echo ""
    h1
    msg "Clipboard"
    xclip -o -selection c
    echo ""
}

watch-xclip-show-all () {
    # watch contents of X11 primary, secondary, and clipboard
    watch -n 1 --color --exec bash -c "source $HOME/.bash_library;xclip-show-all"
}

du-sort () {
    # sort by size after using du
    \du --total --summarize --human-readable -- * 2>/dev/null | sort --human-numeric-sort
}

du-sort-cumulative () {
    # get cumulative sum of sizes using du by sorting smallest to largest
    # get normal du output, not as slow to do it twice because caching
    local DUOUTPUT=$(du-sort)
    # sort by size after using du
    local DUSORT=$(\du --summarize -Bk -- * 2>/dev/null | sort --human-numeric-sort)
    # echo "$DUSORT"
    local TOTALLINES=$(wc -l <<< "$DUSORT")
    local DUSORTCUMULATIVE=""
    # now loop over these
    for i in $(seq 1 1 $TOTALLINES); do
        DUSORTTRIMMED=$(head -n "$i" <<< "$DUSORT")
        # print out sum of lines
        # https://www.linuxquestions.org/questions/linux-newbie-8/how-to-sum-bytes-kilobytes-megabytes-and-gigabytes-using-awk-command-4175439404/
        if [[ "$i" != "$TOTALLINES" ]]; then
            local DUSORTCUMULATIVE="$DUSORTCUMULATIVE"$((awk '{ total = total + $1 } END { print total*1024 }' <<< "$DUSORTTRIMMED") | numfmt --to=iec --padding=7)$'\n'
        else
            local DUSORTCUMULATIVE="$DUSORTCUMULATIVE"$((awk '{ total = total + $1 } END { print total*1024 }' <<< "$DUSORTTRIMMED") | numfmt --to=iec --padding=7)
        fi
    done
    paste <(echo "$DUSORTCUMULATIVE") <(echo "$DUOUTPUT") | column -t
}

du-sort-symlinks () {
    # sort by size after using du
    \du --total --summarize --human-readable --dereference -- * 2>/dev/null | sort --human-numeric-sort
}


du-sort-directories () {
    # sort by size after using du, but show directories only
    # TODO: single file system?
    \du --total --summarize --human-readable -- ./*/ 2>/dev/null | sort --human-numeric-sort
}

du-sort-dotfiles () {
    # sort by size after using du, but show dotfiles only
    du --total --summarize --human-readable .[^.]* 2>/dev/null | sort --human-numeric-sort
}

du-total-symlink () {
    # sort by size after using du, but show symlinks only
    du --total --summarize --dereference --human-readable * 2>/dev/null
}

dd-progress () {
    # check progress of dd commands, this outputs where the dd command is being used
    # TODO: this does not work yet, but trigger all dd commands
    # ps auxww | grep " [d]d " | awk '{print $2}' |while read pid; do kill -USR1 $pid; done
    # http://askubuntu.com/questions/215505/how-do-you-monitor-the-progress-of-dd
    sudo kill -USR1 $(pgrep ^dd)
}

youtube-mp3 () {
    # download mp3 from youtube
    youtube-dl --extract-audio -audio-format mp3 "$1"
}

find-grep () {
    # find then grep
    # TODO: with no arguments give help
    if [[ -z "$2" ]]; then
        find . -type f -exec grep -H --color -n -- "$1" {}  \;
    else
        find . -type f -iname "*$1*" -exec grep -H --color -n -- "$2" {}  \;
    fi
}

harm-bash () {
    # reload bash_profile
    fix-gpg-ssh-permissions
    source "$HOME/.bash_profile"
}

harm-bashrc () {
    # reload bashrc
    fix-gpg-ssh-permissions
    source "$HOME/.bashrc"
}

harm-xresources () {
    # reload x-resources for development purposes
    # otherwise this is is done in bash-profile
    if [[ -f "$HOME/.Xresources" ]]; then
        msg "Loading Xresources!!!"
        xrdb "$HOME/.Xresources"
    fi
}

fix-crypt-permissions () {
    # fix the permissions on a cryptography-relevant directory
    # generally ensures that things are only user readable
    if [[ -z "$1" ]]; then
        yell "Must have a file or directory to fix!"
    else
        # fail silently if does not exist
        if [[ -e "$1" ]]; then
            if [[ -d "$1" ]]; then
                chmod --recursive g-rwx "$1"
                chmod --recursive o-rwx "$1"
                chmod u+rwX --recursive "$1"
            else
                chmod g-rwx $(readlink -f -- "$1")
                chmod o-rwx $(readlink -f -- "$1")
                chmod u+rwX $(readlink -f -- "$1")
            fi
        fi
    fi
}

fix-gpg-ssh-permissions () {
    # fix the permissions on the standard gpg and ssh directory
    fix-crypt-permissions "$HOME/.gnupg"
    fix-crypt-permissions "$HOME/.ssh"
}

backlight-percentage () {
    # check the backlight percentage on
    # XXXX: very device dependent but I find this useful
    # TODO: check that directory exists
    echo $(cat /sys/class/backlight/intel_backlight/brightness*100)/$(cat /sys/class/backlight/intel_backlight/max_brightness) | bc -l | xargs printf "%1.0f\n"
}

vcs-check-root () {
    # check if a pull is needed for for child directories if they correspond to common version control systems
    # stop it from running home because that can cause problems
    # TODO: stop other directories
    if [[ "$PWD" == "$HOME" ]]; then
        yell "Cannot run in home directory!!!"
        return 1
    fi
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        # check for various things
        if [[ -d "$dirname/.git" ]]; then
            # TODO: exclude lines saying [up to date] and just give a summary of branches
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            git -c color.ui=always fetch --verbose
            h2 "pull needed?"
            local STATUS=$(git -c color.ui=always status -uno)
            if grep "up-to-date" <<< "$STATUS" >/dev/null; then
                msg "Seems up to date!"
            else
                yell "Not up to date!"
            fi
            echo "$STATUS"
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Checking $dirname/.hg"
            # TODO: non-functional? I have no remaining hg repos
            # pushd . >/dev/null
            # cd "$dirname"
            # hg fetch --dry-run --verbose
            # popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Checking $dirname/.svn"
            pushd . >/dev/null
            cd "$dirname"
            svn status --show-updates
            popd >/dev/null
        else
            h1 "Not checking $dirname"
        fi
    done
}

vcs-check-root-fetch-all () {
    if [[ "$PWD" == "$HOME" ]]; then
        yell "Cannot run in home directory!!!"
        return 1
    fi
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        if [[ -d "$dirname/.git" ]]; then
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            git fetch
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Pulling $dirname/.hg"
            pushd . >/dev/null
            cd "$dirname"
            # TODO: fix this if I ever have functioning hg repos again
            # hg pull == git fetch
            hg pull
            popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Updating $dirname/.svn"
            yell "Fetching does not make sense for svn!"
            # TODO: fix this if I ever have an svn repo it is needed for
            # TODO: make sure I fix this if I ever have an svn repo it is needed for
            # pushd . >/dev/null
            # cd "$dirname"
            # svn update
            # popd >/dev/null
        else
            h1 "Not pulling $dirname"
        fi
    done
}

vcs-check-root-pull-all () {
    if [[ "$PWD" == "$HOME" ]]; then
        yell "Cannot run in home directory!!!"
        return 1
    fi
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        if [[ -d "$dirname/.git" ]]; then
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            git pull --ff-only
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Pulling $dirname/.hg"
            pushd . >/dev/null
            cd "$dirname"
            # TODO: fix this if I ever have functioning hg repos again
            # hg pull == git fetch
            hg pull
            popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Updating $dirname/.svn"
            yell "Not updating svn until this is fixed!"
            # TODO: make sure I fix this if I ever have an svn repo it is needed for
            # pushd . >/dev/null
            # cd "$dirname"
            # svn update
            # popd >/dev/null
        else
            h1 "Not pulling $dirname"
        fi
    done
}

fail2ban-check () {
    # check fail2ban status and show number of banned IPs for each date in the past
    sudo zcat /var/log/auth.log*.gz | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    # a hack to find non-gz logs
    sudo cat /var/log/auth.lo*[^z] | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    sudo fail2ban-client status ssh
    sudo fail2ban-client status ssh-root
}

drop-caches () {
    # drop caches
    # TODO: should this hae dangerous-function-ask
    su -c "free && sync && echo 3 > /proc/sys/vm/drop_caches && free"
}

mount-disk-uuid () {
    # find the uuid of a mounted disk
    # TODO: change name, this mounts nothing
    # TODO: this will likely become more sophisticated
    local UUID="$1"
    # allow full UUID path to be given
    if [[ "$UUID" == /dev/disk/by-uuid/* ]]; then
        local UUIDDEVICE=$(readlink -f -- "$UUID")
    else
        local UUIDDEVICE=$(readlink -f -- "/dev/disk/by-uuid/$UUID")
    fi
    if findmnt -nr -o target -S "$UUIDDEVICE" >/dev/null; then
        findmnt -nr -o target -S "$UUIDDEVICE"
        return 0
    else
        yell "Disk not mounted!!!"
        return 1
    fi
}

get-mount-point-check-usb () {
    # get the specified mountpoint and make sure it's a usb device
    if [[ -e "/dev/disk/by-uuid/$1" ]]; then
        # argument is a uuid
        local THEDEVICE="/dev/disk/by-uuid/$1"
        local THEMOUNTPOINT=$(findmnt -nr -o target -S "$THEDEVICE")
    elif [[ "$1" == /dev/* ]];then
        # argument is a device
        local THEDEVICE="$1"
        local THEMOUNTPOINT=$(findmnt -nr -o target -S "$THEDEVICE")
    elif mountpoint -q "$1"; then
         # argument already a mount point
         # TODO: use r
         local THEDEVICE=$(findmnt -nr -o source --target "$1")
         local THEMOUNTPOINT="$1"
    else
        # invalid argument
        return 1
    fi
    local LSBLK=$(\lsblk --list --output +tran)
    local LSBLKUSB=$(\lsblk --list --output +tran | grep usb)
    local USBFOUND=
    while read -r USBLINE; do
        local USBDEV=$(awk '{ print $1 }' <<< "$USBLINE")
        # TODO: better string comparison
        if [[ -n "$USBDEV" ]] && grep --color=never "$USBDEV" <<< "$THEDEVICE" >/dev/null;then
            local USBFOUND=1
        fi
    done <<< "$LSBLKUSB"
    if [[ "$USBFOUND" == 1 ]];then
        echo "$THEMOUNTPOINT"
    else
        # argument not usb
        return 1
    fi
}

vcs-diff-public () {
    # diff the "master" with the "public" branch for git repository in the
    # current directory or all child directories that are git repositories
    # only does git until other vcs systems are necessary
    if [[ -d "$PWD/.git" ]]; then
        git diff public..master
    else
        for dirname in ${PWD}/*; do
            if [[ -d "$dirname/.git" ]]; then
                pushd . >/dev/null
                cd "$dirname"
                if git rev-parse --verify public &>/dev/null; then
                    h1 "Checking $dirname"
                    git diff master..public --stat
                fi
                popd >/dev/null
            fi
        done
    fi
}

vcs-push-github () {
    # merge public branch and commit to github
    # XXXX: repository must be setup properly
    # TODO: update versions  in the source files themselves before commit
    ssh-batch -T git@github.com &>/dev/null
    if ! ssh-batch -T git@github.com 2>&1 | grep --color=never "success"; then
        yell "Error connecting to github! Aborting!"
        return 1
    fi
    if ! git -c color.ui=always checkout public; then
        yell "Checkout of public unsuccessful!"
        return 1
    fi
    # TODO: is this safe?
    git -c color.ui=always merge --squash -X theirs master --stat --allow-unrelated-histories
    # TODO: showing files that are different, add this
    # git -c color.ui=always diff public..master --name-status
    local COMMITCORRECT=n
    while [[ "$COMMITCORRECT" != "y" ]]; do
        while read -r -t 0;do read -r; done
        read -e -p "Enter commit message: " COMMITMESSAGE
        while read -r -t 0;do read -r; done
        read -n 1 -p "Use commit message (y/n/q)? " COMMITCORRECT
        echo ""
        if [[ "$COMMITCORRECT" == "q" ]]; then
            yell "Aborting!"
            git -c color.ui=always checkout master
            return 1
        fi
    done
    git -c color.ui=always commit -a -m "$COMMITMESSAGE"
    git -c color.ui=always push --force --set-upstream github public:master
    git checkout master
}

ssh-github-test () {
    # test that I can login to github
    ssh -vvv -T git@github.com
}

vcs-conflicts () {
    # show conflicted files in git
    # TODO: add other vcs if it becomes important
    git diff --name-only --diff-filter=U
}

ag-purge-all () {
    # purge all files related to uninstalled packages
    if dangerous-function-ask; then
        dpkg -l | grep ^rc | cut -d' ' -f3|xargs sudo dpkg --purge
    fi
}

git-serve () {
    # a convienient command to browse code for now
    git instaweb
}

ls-id3 () {
    # list id3 tags of all mp3s in directory
    eyeD3 *.mp3
}

ag-list-doc () {
    # list doc packages, I often grep the output of this
    apt-cache search . | grep -- "\-doc " | cut -d' ' -f1
}

ag-list-packages-only () {
    # list only pakcages without other information
    ag-list-installed | cut -d' ' -f3
}

# the three-fingered claw, see https://stackoverflow.com/questions/1378274/in-a-bash-script-how-can-i-exit-the-entire-script-if-a-certain-condition-occurs
# these are incredibly useful to add to adhoc scripts
# TODO: put in own file so I can copy easily?
yell () {
    # give an error in red
    # TODO: may wish to redefine colors in here? if not already defined?
    local NEWCOM=$(sed -r 's|'"$HOME"'|~|g' <<< "$0")
    echo -e "${BRed}$NEWCOM${Red}: $*${Color_Off}" >&2
}

die () {
    # give and error in red and then exit with 111
    yell "$*"; exit 111
}

try () {
    # try a command
    "$@" || die "cannot $*"
}

warn () {
    # give a warning in yellow
    local NEWCOM=$(sed -r 's|'"$HOME"'|~|g' <<< "$0")
    echo -e "${BYellow}$NEWCOM${Yellow}: $*${Color_Off}" >&2
}

msg () {
    # give a message in green
    local NEWCOM=$(sed -r 's|'"$HOME"'|~|g' <<< "$0")
    echo -e "${BGreen}$NEWCOM${Green}: $*${Color_Off}" >&2
}

h1 () {
    # a top level heading with color
    if [[ -z "$*" ]]; then
        local OUTSTR=$(printf "%.80s" "================================================================================")
    else
        local OUTSTR=$(printf "%.80s" "==== $* ================================================================================")
    fi
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-end () {
    if [[ -z "$*" ]]; then
        local OUTSTR=$(printf "%.80s" "")
    else
        local OUTSTR=$(printf "%.80s" "$*")
    fi
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h1-script () {
    # a top level heading to start a script
    local OUTSTR=$(printf "%.80s" "==== Running $(basename -- $0) ================================================================================")
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-script-end () {
    # a top level heading to end a script
    local OUTSTR=$(printf "%.80s" "Finishing $(basename -- $0)")
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h2 () {
   # a second level heading with color
   if [[ -z "$*" ]]; then
       local OUTSTR=$(printf "%.60s" "----------------------------------------")
   else
        local OUTSTR=$(printf "%.60s" "---- $* ----------------------------------------")
   fi
   # TODO: probably want different color than cyan
   echo -e "${BWhite}${On_Cyan}$OUTSTR${Color_Off}" >&2
}

h3 () {
    # a third level heading with color
    if [[ -z "$*" ]]; then
        local OUTSTR=$(echo "----")
    else
        local OUTSTR=$(echo "---- $*")
    fi
    echo -e "${White}${On_Purple}$OUTSTR${Color_Off}" >&2
}

git-ls () {
    # list files under git version control
    git ls-tree -r master --name-only
}

test-all-colors () {
    # show all terminal colors
    # http://askubuntu.com/questions/27314/script-to-display-all-terminal-colors
    for x in 0 1 4 5 7 8; do
        for i in $(seq 30 37); do
            for a in $(seq 40 47); do
                echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m ";
            done
            echo;
        done
    done
    echo ""
}

vcs-init-full () {
    # init a git repository, add all files, and do an initial commit
    # TODO: check for files existing
    git init && git add * && git commit -a -m 'initial commit'
}

check-emacs-daemon () {
    # check whether an emacs daemon is running
    ps -ef | grep -- '[e]macs --daemon' >/dev/null
    # TODO: change to implicit return once I can test thoroughly
    return $?
}

check-chromium () {
    # check whether the chromium browser is running
    # TODO: this may not be robust
    ps -ef | grep '/usr/lib/chromium/[c]hromium' >/dev/null
    # TODO: change to implicit return once I can test thoroughly
    return $?
}

check-firefox () {
    # check whether a firefox or similar browser is running
    ps -ef | grep '[f]irefox\|[i]ceweasel\|[p]alemoon\|[w]aterfox' >/dev/null
    # TODO: change to implicit return once I can test thoroughly
    return $?
}

disk-info () {
    # get disk info from smartctl for selected disk
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo smartctl -A "$1"
    fi
}

monitor-disks () {
    # this is crude but useful to quickly get information
    disk-info /dev/sda
    disk-info /dev/sdb
    disk-info /dev/sdc
    disk-info /dev/sdd
    disk-info /dev/sde
    disk-info /dev/sdf
}


disk-temp () {
    # get disk temperate from selected disk
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo hddtemp "$1"
        sudo smartctl -A "$1" | grep -i temperature
    fi
}

monitor-disk-temp () {
    # this is crude but useful to quickly get temperature of disks
    disk-temp /dev/sda
    disk-temp /dev/sdb
    disk-temp /dev/sdc
    disk-temp /dev/sdd
    disk-temp /dev/sde
    disk-temp /dev/sdf
}

monitor-disk-speed () {
    # check disk speed
    # https://www.webhostingtalk.com/showthread.php?t=906573
    # http://www.yasith.info/2010/01/how-to-check-hard-disk-performance-and.html
    sudo hdparm -tT /dev/"$1"
}

fix-permissive-permissions () {
    # create permissive permission for a path
    if [[ -e "$1" ]]; then
        chmod 755 "$1"
    fi
}

fix-permissive-permissions-recursive () {
    # recursively create permissive permission for a path
    if [[ -d "$1" ]]; then
        chmod -R 755 "$1"
    fi
}

add-line-if-not-exist () {
    # add a line to a file if the exact line does not exist already
    local THEFILE="$1"
    local NEWLINE="$2"
    # TODO: check grep input before running
    grep -q -F -- "$NEWLINE" "$THEFILE" || echo "$NEWLINE" >> "$THEFILE"
}

kill-blank-lines () {
    # delete any blank lines in a file
    sed -n -e '/^\s*$/d' "$1"
}

screen-select () {
    # select a running screen session using a number (1,2,3...)
    # TODO: do I want to select by letters (a,b,c...) instead???
    local SCREENSESSIONS=$(screen -ls | grep pts | cut -f1 -d"." | sed -e 's/^[[:space:]]*//g')
    if [[ -n "$SCREENSESSIONS" ]]; then
        # set the field separator to new line
        IFS=$'\n'
        # try to iterate over each line
        local count=1
        for item in $SCREENSESSIONS; do
            echo "$count) $item"
            local count=$(( $count + 1 ))
        done
        while read -r -t 0;do read -r; done
        read -n 1 -p "Enter the screen session: " SCREENSELECT
        echo ""
        screen -dr $(sed -n "$SCREENSELECT"p <<< "$SCREENSESSIONS")
    else
        false
    fi
}

file-mimetype () {
    # quick way to get mimetype
    # this should probably be an alias
    file --mime-type "$1"
}

ssh-scs () {
    # XXXX: this one autodetaches after exit from screen session
    ssh "$@" -t "bash --rcfile ~/.bash_library -li -c \"screen-select\""
    # XXXX: this one stays attached after exit from screen session
    # ssh "$@" -t "bash --rcfile ~/.bash_library -li -c \"screen-select;/bin/bash\""
}

focus-emacs-window () {
    # focus an emacs window, useful when tied to hotkeys for some workflows
    wmctrl -x -a emacs.Emacs
}

################################################################################
## enumerate things like block devices

enumerate-physical-disks () {
    # find all physical disks on a linux system
    # TODO: will likely need to be improved for more general use
    for d in /dev/sd*; do
        [[ -b "$d" && ! "$d" =~ .*[[:digit:]] ]] || continue
        echo "$d"
    done
}

enumerate-crypt-disks () {
    # find all decrypted block devices
    # TODO: will likely need to be improved for more general use
    for d in /dev/mapper/crypt--*; do
        [[ -b "$d" ]] || continue
        echo "$d"
    done
}

df-crypt-disks () {
    # get information on decrypted block devices
    df -h $(enumerate-crypt-disks)
}

smartctl-disks () {
    # check overall health of all disks
    for d in $(enumerate-physical-disks); do
        local SMARTOUTPUT=$(sudo smartctl -H "$d")
        if [[ $(($? & 1)) ]]; then
            echo -n "$d: "
            # XXXX: to use this in scripts I have to add smartctl to no password sudo files
            echo "$SMARTOUTPUT" | grep --color=never "overall-health"
        fi
    done
}

smartctl-disks-errors () {
    # check overall health of all disks
    # TODO: current powered up time
    for d in $(enumerate-physical-disks); do
        h2 "$d"
        local POWERONHOURS=$(sudo smartctl -A "$d" | grep Power_On_Hours)
        local SMARTOUTPUT=$(sudo smartctl --log=error "$d")
        if [[ $(($? & 1)) ]]; then
            echo -n "$d: "
            # XXXX: to use this in scripts I have to add smartctl to no password sudo files
            echo "$POWERONHOURS"
            echo "$SMARTOUTPUT"
        fi
    done
}

select-disk-uuid-usb () {
    # select a usb disk using a specific UUID as a default or alternately select a different drive
    # TODO: doesn't work with more than 9 drives, but could be fixed
    # TODO: will I always want to do this with usb? do I want option to select non-usb like FUSE?
    local USBARRAY=()
    if [[ -n "$1" ]]; then
        if [[ -e "/dev/disk/by-uuid/$1" ]]; then
            if findmnt -nr -o target "/dev/disk/by-uuid/$1" >/dev/null; then
                MOUNTPOINT=$(findmnt -nr -o target "/dev/disk/by-uuid/$1")
                DEVICE=$(readlink -f -- "/dev/disk/by-uuid/$1")
                LABEL=$(lsblk --output label "/dev/disk/by-uuid/$1" | tail -n 1)
                printf "0) %-10s %-40s %-25s (default, mounted on $MOUNTPOINT)\n" "$DEVICE" "$1" "$LABEL" >&2
            else
                DEVICE=$(readlink -f -- "/dev/disk/by-uuid/$1")
                LABEL=$(lsblk --output label "/dev/disk/by-uuid/$1" | tail -n 1)
                printf "0) %-10s %-40s %-25s (default, not mounted)\n" "$DEVICE" "$1" "$LABEL" >&2
            fi
        else
            echo "0) $1 (default, not found)" >&2
        fi
    fi
    local count=1
    for d in /dev/disk/by-uuid/*; do
        [[ "$d" == "/dev/disk/by-uuid/$1" ]] && continue
        if /sbin/udevadm info --query=all --name=$(readlink -f -- "$d") | grep 'ID_BUS=usb' >/dev/null; then
            if findmnt -nr -o target "$d" >/dev/null; then
                MOUNTPOINT=$(findmnt -nr -o target "$d")
                LABEL=$(lsblk --output label "$d" | tail -n 1)
                printf "$count) %-10s %-40s %-25s (mounted on $MOUNTPOINT)\n" $(readlink -f -- "$d") $(basename -- "$d") "$LABEL" >&2
            else
                LABEL=$(lsblk --output label "$d" | tail -n 1)
                printf "$count) %-10s %-40s %-25s (not mounted)\n" $(readlink -f -- "$d") $(basename -- "$d") "$LABEL" >&2
            fi
            local count=$(( $count + 1 ))
            USBARRAY+=("$d")
        fi
    done
    # echo "$count) Non-USB drive" >&2
    echo "-) Cancel" >&2
    while read -r -t 0;do read -r; done
    read -n 1 -p "Enter the USB drive: " USBSELECT >&2
    echo "" >&2
    if [[ "$USBSELECT" == "0" ]]; then
        echo /dev/disk/by-uuid/"$1"
        return 0
    fi
    if [[ "$USBSELECT" == "-" ]]; then
        echo "Canceled!" >&2
        return 1
    fi
    if ! [[ "$USBSELECT" =~ ^[0-9]$ ]] || (( $USBSELECT >= $count )); then
        return 1
    fi
    local USBSELECT=$(( $USBSELECT - 1 ))
    # TODO: ensuring only proper selection is returned, avoid use of tail
    echo ${USBARRAY[$USBSELECT]}
    return 0
}

select-disk-uuid-info () {
    # query disk info for testing and debugging purposes
    # TODO: need proper columns
    # TODO: query only USB
    # TODO: handle encrypted disk better
    echo "ID: "
    for d in /dev/disk/by-id/*; do
        echo "$d: $(readlink -f $d) $(/sbin/udevadm info --query=all --name=$(readlink -f -- $d) | grep ID_BUS)"
    done
    echo ""
    echo "UUID: "
    for d in /dev/disk/by-uuid/*; do
        echo "$d: $(readlink -f $d) $(/sbin/udevadm info --query=all --name=$(readlink -f -- $d) | grep ID_BUS)"
    done
}

dangerous-function-ask () {
    # ask whether to continue with a dangerous function
    if ask_yn "Dangerous function! Continue"; then
        return 0
    else
        return 1
    fi
}

continue-ask () {
    # aak whether to continue
    if ask_yn "Continue"; then
        return 0
    else
        return 1
    fi
}

vcs-grep-conflicted () {
    # find git or other VCS conflicted markers in current directory tree
    # TODO: a proper return values?
    # TODO: avoid running /home or above... takes way too long!
    find . -not -path "*.git*" -type f -exec grep -nH --color -- "^<<<<<<< \|^>>>>>>> \|^=======$\|^####### " {} \;
}

mdstat-status () {
    # check mdstat with just a summary, use as a quick text summary for system monitors
    local MDSTAT=$(cat /proc/mdstat | sed -n '/^md\|^[[:space:]]*\[\|blocks/p')
    local FIRST=1
    IFS=$'\n'
    for i in $(echo "$MDSTAT"); do
        if [[ "$i" =~ ^m.* ]]; then
            printf "$i"
        else
            local SELECTED=$(grep --color=never -Eo -- "\[[A-Za-z]*\]$" <<< "$i")
            if [[ -n "$SELECTED" ]]; then
                echo " $SELECTED"
            fi
        fi
    done
}

repl-restartable () {
    # restart a repl over and over again if desired
    local TRYAGAIN=" "
    while [[ "$TRYAGAIN" == " " ]]; do
        ($@)
        local RETURNVALUE=$?
        echo "repl-restartable return code: $RETURNVALUE"
        if [[ "$RETURNVALUE" == 255 ]]; then
            # TODO: better return values than this?
            return 255
        fi
        while read -r -t 0;do read -r; done
        IFS= read -n 1 -s -p 'Press [Enter] to exit or [Space] to restart...' TRYAGAIN
        if [[ "$TRYAGAIN" == " " ]]; then
            reset
        fi
    done
    return 0
}

gpg-decrypt () {
    # decrypt a batch file
    gpg-batch --decrypt "$1" 2>/dev/null
}

transform-svg2png-hq () {
    # convert an svg to a png in high quality
    if [[ -z "$1" ]]; then
        yell "No input!"
        return 1
    fi
    local OUTPUT="${1%%.svg}.png"
    if [[ -f "$OUTPUT" ]]; then
        yell "Output $OUTPUT already exists!!!"
        return 1
    else
        convert -density 300 -resize 2000x "$1" "$OUTPUT"
    fi
}

function ls-cron () {
    # list the current users crontab
    crontab -u "$USERNAME" -l
}

function ag-rdep () {
    # search for reverse dependencies of a package
    # TODO: add help
    apt-cache rdepends "$1"
}

function ag-rdep-installed () {
    # search for reverse dependencies installed for a package
    # TODO: add help
    apt-cache rdepends "$1" --installed
}

function ls-mime-files () {
    # list mime settings by enumerating all possible files where they could be
    # https://wiki.archlinux.org/index.php/default_applications
    local THEFILES=("$HOME/.config/$desktop-mimeapps.list" "$HOME/.config/mimeapps.list" "/etc/xdg/mimeapps.list" "$HOME/.local/share/applications/mimeapps.list" "/usr/local/share/applications/mimeapps.list" "/usr/share/applications/mimeapps.list")
    for f in ${THEFILES[@]}; do
        if [[ -e "$f" ]]; then
            h3 "$f"
            cat "$f"
        else
            warn "$f not exist!"
        fi
    done
}

function ls-mime-files2 () {
    # list useful information related to mime settings
    # see https://unix.stackexchange.com/questions/36380/how-to-properly-and-easy-configure-xdg-open-without-any-enviroment
    # TODO: make more robust and more usefully named next time this is need
    for thedir in /usr/share/applications $HOME/.local/share/applications; do
        h2 "$thedir"
        for thefile in $(ls "$thedir" 2>/dev/null | grep "\\.desktop$"); do
            h3 "$thefile"
            for m in $(grep MimeType "$thedir/$thefile" | cut -d= -f2 | tr ";" " "); do
                echo xdg-mime default "$thefile" "$m"
            done
        done
    done
}

caps-toggle () {
    # toggle caps lock from command line just in case
    xdotool key Caps_Lock
}

flatten-current-directory () {
    # flatten the current directory tree
    # TODO: warn how destructive this actually is,
    if [[ $@ != *"--for-real"* ]]; then
        find . -mindepth 2 -type f -exec mv {} .
    else
        yell "Dangerous function!!! Use --for-real!!!"
    fi
}

dunst-notifications () {
    # list dunst desktop notification that have appeared
    printf "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    grep "summary: \|body: " "$HOME/tmp/dunst-current.log" | grep -v \'\' | sed -e 's/^[ \t]*//' | sed -e 's/body: /    /' | sed -e 's/summary: //'
}

ag-list-explicitly-installed () {
    # list the package that apt has explicitly installed
    aptitude search '~i !~M'
}

show-all-x-displays () {
    # show all x11 displays on the current machine (even if $DISPLAY is not set)
    cd /tmp/.X11-unix && for x in X*; do echo ":${x#X}"; done
}

phoronix-describe-all-tests () {
    # describe all tests in the phoronix test suit
    (IFS=$'\n'
     for testline in $(\phoronix-test-suite list-available-tests | tail -n +5 | head -n -2); do
         h2 $(awk '{ print $1 }' <<< "$testline")
         \phoronix-test-suite info $(awk '{ print $1 }' <<< "$testline")
     done)
}

inhibit-powersave () {
    # make sure screensaver and other power saving does not start does not restart
    # useful for times where screensavers and other power/screensaving features would be detrimental
    # TODO: inhibit power management too
    # TODO: quite loop and reenable disabled features
    while true; do
        echo "Trying..."
        xscreensaver-command -exit
        # https://bbs.archlinux.org/viewtopic.php?id=134289
        screensaver-builtin-disable
        cpu-throttle-up
        sleep 15
    done
}

inhibit-tty-powersave () {
    # explicitly disable powersave in ttys
    # I usually do this automatically but it helps to have this
    setterm -blank 0 -powersave off
}

screensaver-disable () {
    # disable xscreensaver and other powersaving commands
    xscreensaver-command -exit
    xset s 0 0 s noblank
    xset s off
    xset dpms 0 0 0
    xset -dpms
}

screensaver-enable () {
    # reenable xscreensaver and other powersaving commands
    (nohup xscreensaver -nosplash &>/dev/null &)
    xset s 0 0 s noblank
    xset s off
    xset dpms 0 0 0
    xset -dpms
}

grep-commands () {
    # print out matching commands that can be run from the shell
    h1 'Commands in $PATH'
    printf '%s\n' ${PATH//:/\/* } | grep -- "$1"
    h1 "Bash functions"
    declare -F | grep -- "$1"
    h1 "Aliases"
    alias | grep -- "$1"
}

rsync-remove-source () {
    # rsync and remove source, but also backup just in case
    # TODO: better interface and safety
    if [[ ! -d "$2" ]]; then
        yell "Empty directory argument!!!"
        return 1
    fi
    # TODO: check here!
    if ssh "$1" true; then
        msg "Incoming from $1"
        local BACKUPDIR="rsync-backups-$1-$(date-time-stamp)"
        rsync --progress --archive --checksum --backup --backup-dir="$BACKUPDIR" --rsh='ssh' --remove-source-files "$1:$2/" .
        # will cause error if there are backups
        rmdir --ignore-fail-on-non-empty "$BACKUPDIR"
    else
        warn "Hostname $1 not found!"
    fi
}

rsync-check-source () {
    # check before running rsync-remove-source with same arguments
    if ssh "$1" true; then
        # TODO: make explicitly that contents of that directory come into current directory
        rsync --verbose --checksum --progress --archive  --rsh='ssh' "$1:$2/" .
    else
        warn "Hostname $1 not found!"
    fi
}

vcs-incoming () {
    # see what would be changed with a git pull
    h2 "The log: "
    # TODO: configure a little better, want to see on screen and not always in a pager
    git log --decorate=full --graph --stat ..origin/"$(git rev-parse --abbrev-ref HEAD)"
    read -n 1 -s -r -p "Press any key to continue... "
    echo ""
    h2 "The diffs: "
    git diff --stat @{upstream}
    git diff @{upstream}
}

git-reset () {
    # reset git repository
    # TODO: often used to reset and pull
    # dangerous command, check first
    if dangerous-function-ask; then
        git reset --hard HEAD
    fi
}

trim-mp3-to-30min-skip-first-30s () {
    # trim an mp3 but skip first 30s
    # often used to reduce recordings of white noise to mp3 player size
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 00:30:00 "$2"
}

trim-mp3-to-30min () {
    # trim an mp3 to 30min
    ffmpeg -i "$1" -codec copy -ss 00:00:00 -t 00:30:00 "$2"
}

trim-mp3-to-1hr-skip-first-30s () {
    # trim an mp3 to 1 hour but skip first 30s
    # often used to reduce recordings of white noise to mp3 player size
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 01:00:00 "$2"
}

trim-mp3-to-1hr () {
    # trim an mp3 to 1 hour
    ffmpeg -i "$1" -codec copy -ss 00:00:00 -t 01:00:00 "$2"
}

trim-mp3-to-2hr-skip-first-30s () {
    # trim an mp3 to 2 hours but skip first 30s
    # often used to reduce recordings of white noise to mp3 player size
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 02:00:00 "$2"
}

trim-mp3-to-2hr () {
    # trim an mp3 to 2 hours
    ffmpeg -i "$1" -codec copy -ss 00:00:00 -t 02:00:00 "$2"
}

normalize-volume () {
    # set system volume to nice levels on one run
    amixer set Master 50%
    amixer set Master unmute
    # youtube volume sometimes stupid, normalize it too
    youtube-normalize-volume
    local DATESTAMP=$(date-time-stamp)
    notify-send "Normalizing volume" "$DATESTAMP" -t 5000
}

youtube-normalize-volume () {
    # global function to normalize volume in youtube windows
    # often tied to a hotkey
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if [[ -n "$line" ]] && xdotool search --class conkeror | grep -- "$line" >/dev/null; then
            xdotool windowfocus --sync "$line"
            xdotool windowactivate --sync "$line"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.05
            conkeror-batch -f youtube-normalize-volume
        fi
    done
    # TODO: very arbitrary, perhaps wait for something to return
    sleep 0.05
    xdotool windowactivate --sync "$CURRENTWINDOW"
}

find-iname () {
    # find matching files, one of my most used functions
    find . -iname '*'"$1"'*'
}

xset-query () {
    # query xset options
    xset -q
}

grep-gz-files () {
    # gz files, but only elisp for now
    # TODO: make more general
    find -name "*.el.gz" -print0 | xargs -0 zgrep "$1"
}

strip-leading-trailing-chars () {
    # strip leading and trail characters I do not want for many applications
    # TODO: keep adding more as I need them
    read string
    echo "$string" | sed 's/^[-]*//' | sed 's/[-]*$//'
}

gpg-batch () {
    # run gpg with appropriate options for batch mode
    gpg2 --no-verbose --quiet --batch --yes "$@"
}

harm-fonts () {
    # reconfigure and recache fonts, rarely run but useful to have
    sudo dpkg-reconfigure fontconfig
    echo "To force font caching run: fc-cache -f -v"
}

benchmark-compression-gzip () {
    # benchmark gzip compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tgz)
    time {
        tar --create --file - "$1" | gzip -1 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        gzip -d "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-bzip2 () {
    # benchmark bzip2 compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.bz2)
    time {
        tar --create --file - "$1" | bzip2 -9 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        bzip2 -d "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-lz4 () {
    # benchmark lz4 compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.lz4)
    time {
        tar --create --file - "$1" | lz4 -1 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        lz4 -d "$THETEMPFILE" &>/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-lzop () {
    # benchmark lzop compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.lzop)
    time {
        tar --create --file - "$1" | lzop -6 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        lzop -d -c "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-rzip () {
    # benchmark rzip compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --dry-run --suffix=.tar.rz)
    time {
        tar --create --file - "$1" > test.tar
        rzip -3 test.tar -o "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        rzip -d "$THETEMPFILE"
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

# TODO: will not work on directories for now
# TODO: do later
# benchmark-compression-lrzip () {
#     # benchmark lzip compression
#     du -sh "$1"
#     local THETEMPFILE=$(mktemp tmp-benchmark-compression-XXXXXXXXXX --dry-run --suffix=.tar.lrzip)
#     time {
#         lrzip --level 9 "$1" --outfile "$THETEMPFILE"
#     }
#     echo ""
#     du -sh "$THETEMPFILE"
#     time {
#         lrzip -d "$THETEMPFILE" --outfile /dev/null
#     }
#     sleep 2
#     rm "$THETEMPFILE"
# }

benchmark-compression-lzip () {
    # benchmark lzip compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.lzip)
    time {
        tar --create --file - "$1" | lzip -9 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        lzip -d -c "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-xz () {
    # benchmark lz compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.xz)
    time {
        tar --create --file - "$1" | xz -9 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        xz -d "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-zip () {
    # benchmark zip compression on a selected file or directory
    # TODO: this isn't what is wanted for benchmarking extremely large things that might fill up the disk
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --dry-run --suffix=.zip)
    time {
        zip "$THETEMPFILE" "$1"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        unzip -p "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-all () {
    # benchmark all supported compression methods on a selected file or directory
    h2 "gzip"
    benchmark-compression-gzip "$1"
    h2 "bzip2"
    benchmark-compression-bzip2 "$1"
    h2 "lz4"
    benchmark-compression-lz4 "$1"
    h2 "lzop"
    benchmark-compression-lzop "$1"
    h2 "lzip"
    benchmark-compression-lzip "$1"
    h2 "rzip"
    benchmark-compression-rzip "$1"
    h2 "xz"
    benchmark-compression-xz "$1"
    h2 "zip"
    benchmark-compression-zip "$1"
}

pdftk-cat () {
    # create pdf from alphabetically-order pdfs in current directory, using pdftk
    if [[ -z "$1" ]]; then
        echo "pdftk-cat <<pdf basename to create>>"
    else

        pdftk *.pdf cat output "$1".pdf
    fi
}

pdftk-split () {
    # split pdf from start page to end page
    if [[ -z "$1" ]]; then
        echo "pdftk-split <<pdf filename in>> <<start page>> <<end page>>" "<<pdf filename out>>"
        echo "Use page numbering and not page naming."
    else
        pdftk "$1" cat "$2"-"$3" output "$4"
    fi
}

alias cdf="cd-first"
cd-first () {
    # go to the first directory matching pattern
    local FIRST=$(ls --color=never -dtr1 "$1"* | head -1)
    cd "$FIRST"
}
alias lsf="ls-first"
ls-first () {
    # ls the first directory matching pattern
    local FIRST=$(ls --color=never -dtr1 "$1"* | head -1)
    ls "$FIRST"
}

alias cdl="cd-latest"
cd-latest () {
    # go to the lastest matching pattern based on alphabetically ordered datestamps
    local LATEST=$(ls --color=never -dtr1 "$1"* | tail -1)
    cd "$LATEST"
}
alias lsl="ls-latest"
ls-latest () {
    # ls the lastest matching pattern based on alphabetically ordered datestamps
    local LATEST=$(ls --color=never -dtr1 "$1"* | tail -1)
    ls "$LATEST"
}

list-x11-displays () {
    # list all x11 displays on the local machine
    pushd . >/dev/null
    cd /tmp/.X11-unix
    for x in X*; do
        echo ":${x#X}"
    done
    popd >/dev/null
}

screen-list-all-session-commands () {
    # lists all non-bah child processes running in bash
    SCREEN_SESSIONS=( $(screen -ls | grep pts | cut -f1 -d"." | sed -e 's/^[[:space:]]*//g') )
    for SCREEN_SESSION_PID in "${SCREEN_SESSIONS[@]}";do
        h2 "Screen session pid: $SCREEN_SESSION_PID"
        screen -ls "$SCREEN_SESSION_PID"
        # TODO: will all screens have bash base
        SCREEN_CHILD=$(ps -el | grep -- $(ps -el | grep "$SCREEN_SESSION_PID" | grep bash | awk '{print $4}') | grep -v bash | awk '{print $4}')
        if [[ -n "$SCREEN_CHILD" ]]; then
            echo $(ps u -p "$SCREEN_CHILD") | fold -w 160
        else
            warn "No non-bash child process!"
        fi
    done
}
alias scl-commands="screen-list-all-session-commands"

ag-sizes () {
    # get sorted sizes of packages installed
    dpkg-query -Wf '${Installed-Size}\t${Package}\n' | sort --numeric -
}

screen-default () {
    # default screen command, ensures a simple 'screen' command does nothing, butit can still be run with options
    if [[ -z "$1" || ! "$1" =~ ^- ]]; then
        yell "Default screen must have options associated with it! Use sc command to start screen instead!"
        return 1
    fi
    \screen "$@"
}
alias screen='screen-default'

screen-name () {
    # get the name of a screen session
    if [[ -z "$1" ]]; then
        yell "Must specify screen session name!!!"
        return 1
    fi
    local SCREEN_SESSION="$1"
    shift
    screen -S "$SCREEN_SESSION" "$@"
}
alias sc='screen-name'

find-newest-modified () {
    # find the most recently modified files
    find . -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head -n 20
}

tar-to-here () {
    # tar a file/directory to a file in current directory
    tar cvzf ./"$2".tgz "$1"
}


un-human-readable () {
    # https://stackoverflow.com/questions/26621647/convert-human-readable-to-bytes-in-bash
    for v in "$@"; do
        echo $v | awk \
          'BEGIN{IGNORECASE = 1}
           function printpower(n,b,p) {printf "%u\n", n*b^p; next}
           /[0-9]$/{print $1;next};
           /K(iB)?$/{printpower($1,  2, 10)};
           /M(iB)?$/{printpower($1,  2, 20)};
           /G(iB)?$/{printpower($1,  2, 30)};
           /T(iB)?$/{printpower($1,  2, 40)};
           /KB$/{    printpower($1, 10,  3)};
           /MB$/{    printpower($1, 10,  6)};
           /GB$/{    printpower($1, 10,  9)};
           /TB$/{    printpower($1, 10, 12)}'
    done
}

WGETOKCODES="200 OK\|302 Found"
WGETERRORCODES="301 Moved Permanently\|404 Not Found\|406 Not Acceptable\|503 Service Unavailable\|504 Gateway Time-out\|Read error\|416 Requested Range Not Satisfiable\|300 Multiple Choices\|500 Internal Server Error\|^Error\|^Retrying\|^Giving\|Data connection: Connection timed out"

wget-check-log-unknown-codes () {
    # check a wget log for unknown error codes
    grep -Hn -- "awaiting response" "$1" | grep -v -- "$WGETOKCODES"  | grep -v -- "$WGETERRORCODES"
    # TODO: more informative return code?
    return 0
}

wget-check-log () {
    # check a wget log for error codes
    h1 "Error codes"
    grep --color=always -Hn -B 2 -A 4 -- "$WGETERRORCODES" "$1"
    h1 "Unknown codes"
    wget-check-log-unknown-codes "$1"
}

ls-archive () {
    # list files in an archive
    # TODO: add help and more suppot
    if [[ "$1" == *.tar* || "$1" == *.tgz ]]; then
        tar-ls "$1"
    elif [[ "$1" == *.zip ]]; then
        unzip -l "$1"
    elif [[ "$1" == *.rar ]]; then
        unrar l "$1"
    fi
}

tar-ls () {
    # list files in a tar archive
    # TODO: combine with ls-archive?
    if [[ "$1" == *.tar.gz || "$1" == *.tgz ]]; then
        tar -ztf "$1"
    else
        tar -tf "$1"
    fi
}

ls-grep () {
    # a simple function for easily searches of a directory, one of my most used function
    ls --color=always -1 | grep --color=always -i -- "$1"

}
alias grep-ls="ls-grep"

grep-less () {
    # grep but view in less
    grep --color=always -Ri $@ | less -r
}
alias less-grep="grep-less"

sqlite-cat () {
    # view an sqlite3 database
    sqlite3 "$1" .dump | less
}
alias cat-sqlite="sqlite-cat"

unzip-all () {
    # unzip all zip files in directory into their own directory based on zipfile name
    # TODO: add a dangerous-function-ask check?
    for F in ./*.zip; do
        mkdir -p "$F.d"
        pushd . >/dev/null
        cd "$F.d"
        unzip ../"$F"
        popd >/dev/null
    done
}

unzip-in-path () {
    # unzip a zip file into its own directory
    if [[ -n "$1" ]] || [[ -f "$1" ]]; then
        mkdir -p "$1.d"
        cd "$1.d"
        unzip ../"$1"
    else
        yell "Does not exist or is not a file!"
    fi
}


unzip-ls () {
    # list contents of all zipfiles in path
    # TODO: check if zip is not here
    for F in ./*.zip; do
        h2 "$F"
        unzip -l "$F"
    done
}


grep-ri () {
    # recursive case insensitive grep, one of my most use functions
    # TODO: add more exclude
    grep --color=always -Ri "$@" . | grep -v "\\.git/" | less -R
}

less-highlight () {
    # use less and highlight using Python pygments
    # TODO: a bit slow but looks really good
    if [[ -z "$1" ]]; then
        echo "A filename is required for less-highlight!"
    elif [[ -e "$1" ]]; then
        pygmentize -O style=native -g -f terminal256 "$1" | less --IGNORE-CASE --LONG-PROMPT --RAW-CONTROL-CHARS +Gg
    else
        echo "File $1 does does not exist!"
    fi
}
# one of my host used aliases
alias lh='less-highlight'

less-sh () {
    # faster than less-highlight ... but looks terrible by default
    # TODO: fix colors on this
    /usr/share/source-highlight/src-hilite-lesspipe.sh "$1" | less
}

geotiff-info () {
    # get info of geotiff files in current directory
    for F in $@; do
        # TODO: better pattern
        [[ "$F" =~ "tif" ]] || continue
        h2 "$F"
        gdalinfo "$F"
    done
}

check-git-repo () {
    # check if we are currently within a valid git repository
    [[ -d .git ]] || git rev-parse --git-dir &>/dev/null
}

ag-reinstall-all () {
    # reinstall all apt packages
    if dangerous-function-ask; then
        sudo dpkg --get-selections | awk '{print $1}' > "/tmp/cic-dkpg-list.log"
        for i in $(cat /tmp/cic-dkpg-list.log); do
            sudo apt-get install --reinstall "$i"
        done
    fi
}

ag-reinstall-dependent () {
    # reinstall all apt packages that are dependencies of a particular package
    if [[ -n "$1" ]]; then
        if dangerous-function-ask; then
            # https://askubuntu.com/questions/275719/reinstall-package-and-its-installed-dependencies
            sudo apt-cache depends "$1" | grep '[ |]Depends: [^<]' | cut -d: -f2 | tr -d ' ' | xargs sudo apt-get --reinstall install -y
        fi
    fi
}

check-permissions-rw () {
    # find files I do not own in the current path
    h3 "Files not owned or in my group"
    find . ! -user "$USER"
    h3 "Directories I do not have sufficient privileges for"
    # TODO: exclude .git
    find . -type d -user "$USER" ! -perm -700
    h3 "Files I do not have sufficient privileges for"
    # TODO: exclude .git
    find . -user "$USER" ! -perm -600
}

ls-sqlite-tables () {
    # list table in an sqlite database
    sqlite3 "$1" '.tables'
}

cat-all () {
    # cat all files in the directory
    for F in ./*; do
        h1 "$F"
        cat "$F"
    done
}

ask_yn () {
    # ask a yes or no question, repeat until y or n is entered
    local YN=
    while [[ "$YN" != 'y' && "$YN" != 'n' ]]; do
        while read -r -t 0;do read -r; done
        read -n 1 -p "$1 (y/n)? " YN
        echo ""
    done
    if [[ "$YN" == 'y' ]]; then
        return 0
    elif [[ "$YN" == 'n' ]]; then
        return 1
    fi
}

convert-size-to-bytes () {
    # convert a size with units (K,M,G) to bytes
    # use 1000 for kB MB GB
    # TODO: deal with trailing B
    # TODO: expand to terabyte and petabyte
    echo "$1" | sed 's/G/ * 1000 M/;s/M/ * 1000 K/;s/K/ * 1000/; s/$/ +\\/; $a0' | bc
}

convert-size-to-bytes-1024 () {
    # convert a size with units (K,M,G) to bytes
    # use 1024 for kiB MiB GiB
    # TODO: expand to terabyte and petabyte
    # TODO: deal with trailing B
    echo "$1" | sed 's/G/ * 1024 M/;s/M/ * 1024 K/;s/K/ * 1024/; s/$/ +\\/; $a0' | bc
}

tar-bzip2-remove () {
    # this tars then bzips a directory and then removes the original directory
    # TODO: dangerous, I have some checks but needs more
    # XXXX: this uses $HOME/tmp as temp directory because that has often more space than /tmp on my machines
    # make sure there are no errors except sockets
    # make sure source exists and destination does not
    echo "----------------------------------------"
    if [[ -n "$3" ]]; then
        echo "Too many arguments!"
        return 1
    fi
    echo "Dangerous function! Sleeping for 10s!"
    sleep 10
    mkdir -p "$HOME/tmp"
    if [[ -z "$1" && ! -d "$1" ]]; then
        echo "First argument $1 must be specificed and it must exist as a directory!"
        return 1
    fi
    if [[ -z "$2" && -e "$2" ]]; then
        echo "Second argument $2 must be specificed as destination and it must not exist!"
        return 1
    fi
    local INFULLPATH=$(readlink -f -- "$1")
    local OUTFULLPATH=$(readlink -f -- "$2")
    # TODO: quit if readlink fails?
    local INSIZE=$(du -sh "$1")
    if [[ "$OUTFULLPATH" == "$INFULLPATH"/ ]]; then
        echo "$OUTFULLPATH must not be contained in $INFULLPATH!"
        return 1
    fi
    if [[ "$INFULLPATH" != "$HOME"/?*/?* ]];then
        echo "$INFULLPATH must be contained in a top level directory of $HOME!"
        return 1
    fi
    if [[ "$OUTFULLPATH" != "$HOME"/?*/?* ]];then
        echo "$OUTFULLPATH must be contained in a top level directory of $HOME!"
        return 1
    fi
    # check if successful, need temp files
    # https://stackoverflow.com/questions/1550933/catching-error-codes-in-a-shell-pipe
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-bzip-remove-XXXXXXXXXX" --suffix=.tar)
    echo "Tarring $1 to $THETEMPFILE..."
    time {
        tar --create --file - "$1" > "$THETEMPFILE"
    }
    if [[ $? != 0 ]]; then
        echo "Error creating $1 while creating $THETEMPFILE!"
        [[ -e "$THETEMPFILE" ]] && \rm "$THETEMPFILE"
        return 1
    fi
    echo "Compressing $THETEMPFILE to $2..."
    time {
        bzip2 --stdout -9 "$THETEMPFILE" > "$2"
    }
    if [[ $? != 0 ]];then
        echo "Error during compression!"
        [[ -e "$THETEMPFILE" ]] && \rm "$THETEMPFILE"
        return 1
    fi
    [[ -e "$THETEMPFILE" ]] && \rm "$THETEMPFILE"
    local OUTSIZE=$(du -sh "$2")
    echo "Size reduced from $INSIZE to $OUTSIZE."
    echo "Creating $2 from $1 successful!"
    echo "Deleting $1 in 10s!"
    sleep 10
    # TODO: this is dangerous
    \rm -rf "$1"
}

ssh-check-host () {
    # check if an ssh host port 22 is alive
    if [[ -z "$1" ]];then
        return 1
    fi
    nc -z "$1" 22 >/dev/null
}

ssh-check-host-verbose () {
    # check if an ssh host port 22 is alive but be verbose
    if [[ -z "$1" ]];then
        warn "Must specify host!"
        return 1
    fi
    nc -z -v "$1" 22
}

ag-list-manual-alternatives () {
    # list alternatives set manually in debian
    # https://wiki.debian.org/DebianAlternatives
    for i in /etc/alternatives/*; do
        LANG=C update-alternatives --display "${i#/etc/alternatives/}"
    done 2>/dev/null | awk '/manual.mode/{print $1}'
}
