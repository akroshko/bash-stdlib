#!/bin/bash
# bash_functions_stdlib is a set of bash functions for non-specific
# functionality.
#
# Copyright (C) 2015-2018, Andrew Kroshko, all rights reserved.
#
# Author: Andrew Kroshko
# Maintainer: Andrew Kroshko <akroshko.public+devel@gmail.com>
# Created: Fri Mar 27, 2015
# Version: 20180622
# URL: https://github.com/akroshko/bash-stdlib
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

# WARNING: most of this code has not been rigorously tested or
# verified, use at own risk if working with important data or in
# production settings

test-fail () {
    # this function is just a test to judge a scripts behaviour based
    # on return values
    # TODO: also need a test error
    if [[ false ]]; then
        echo "false"
        return 1
    fi
    echo "not false"
    return 0
}

check-host () {
    # check if current host is a particular host, this will probably
    # become more complex as time goes on
    [[ "${HOSTNAME}" == "$1" ]]
}

need_new_directory () {
    # create a new directory if it does not already exist
    mkdir -p "$1"
}

verify-operation () {
    # this function verifies a deletion and asks twice to make sure,
    # generally used to ensure an operation is successful before
    # deleting
    local ASKMESSAGE="$1"
    local SUREMESSAGE="$2"
    local RMARG="$3"
    while true; do
        while read -r -t 0;do read -r; done;
        read -n 1 -p "$ASKMESSAGE" YN
        echo ""
        case $YN in
            # TODO: make a bit more general so I can select a command
            [Yy]* ) (home-trash "$RMARG"); break;;
            # are you sure you don't want to delete original
            [Nn]* )
                while read -r -t 0;do read -r; done;
                read -p "$SUREMESSAGE" YNT
                case $YNT in
                    [Yy]* ) return 0;;
                    [Nn]* ) true;;
                    * ) warn "Try again!"
                esac
                ;;
            * ) warn "Please answer yes or no.";;
        esac
    done
}

home-trash () {
    # delete by moving to a trash file that can be periodically
    # checked
    local TRASHFILE="$1"
    mkdir -p ${HOME}/tmp/trash
    \mv --backup=t -- "$TRASHFILE" ${HOME}/tmp/trash
}

date-time-stamp () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%d%H%M%S)
}

date-time-stamp-t () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%dT%H%M%S)
}

date-stamp () {
    echo $(date +%Y%m%d)
}

# move this to function ASAP
memory-log () {
    while true; do { cat /proc/meminfo | sed -n 2p ; date ; } | tr "\n" " " ; echo ""; sleep 30; done >> ${HOME}/memory-$(date +%Y%m%d%H%M%S).log
}

ag-show () {
    # show details of a debian package
    apt-cache show "$1"
}
# XXXX: only different when using bash completion
alias ag-show-installed=ag-show

# TODO: search multiple terms?
ag-search () {
    # search for a debian package
    apt-cache search "$1"
}

ag-install () {
    # TODO: check if already installed
    # TODO: no sudo for dry run??? abort if can't sudo?
    # TODO: check if apt-get update needed
    apt-get install --dry-run "$@"
    echo "Do install for real?"
    # install a debian package
    read -n 1 -p "Install? (y/n)? " yn
    echo ""
    if [[ "$yn" == 'y' ]]; then
        sudo apt-get install "$@"
    else
        msg "Aborting!"
    fi
}

ag-install-dry-run () {
    apt-get install --dry-run "$@"
}

ag-remove () {
    # uninstall a debian package
    sudo apt-get remove "$@"
}

ag-list () {
    # list files installed by a debian package
    dpkg-query -L "$1"
}

# TODO: search multiple terms?
ag-list-installed () {
    if [[ -z "$1" ]]; then
        dpkg-query -l
    else
        dpkg-query -l | grep -- "$1"
    fi
}

# TODO: see if I can use aes256-gcm@openssh.com for everything

ssh-batch () {
    ssh -o "BatchMode yes" "$@"
}

ssh-batch-lan () {
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" "$@"
}

ssh-batch-interact () {
    # go in in batch mode but allow interaction
    # generally want things to fail when authentication agents not working
    ssh -o "BatchMode yes" -t "$@"
}

ssh-batch-interact-lan () {
    # go in in batch mode but allow interaction
    # generally want things to fail when authentication agents not working
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" -t "$@"
}

ssh-lan () {
    ssh -o "Compression no" "$@"
}

scp-lan () {
    # use scp over a LAN, sets some good options
    scp -o "Compression no" "$@"
}

sftp-lan () {
    # use sftp over a LAN, sets some good options
    sftp -o "Compression no" "$@"
}


sshx () {
    ssh -X -o "Compression yes" "$@"
}

sshnox () {
    # use ssh and explicitly disable X forwarding
    ssh -o "ForwardX11 no" "$@"
}

sshx-lan () {
    ssh -X -o "Compression no" "$@"
}

autossh-tunnel () {
    # set up a tunnel using autossh
    autossh -M 0 -o "BatchMode yes" -o "Compression yes" -N "$@"
}

autossh-tunnel-lan () {
    # set up a tunnel using autossh, compression off best for lan
    autossh -M 0 -o "BatchMode yes" -o "Compression no" -N "$@"
}

transform-resize-web () {
    # resize photos to a nice size for the web
    # TODO: change the prefix name?
    convert "$1" -resize 1200x800 "resize_$1"
}

# transform anything to mp3 using ffmpeg
transform-ffmpeg-mp3 () {
    # convert any media file to an mp3
    # TODO: ffmpeg not on debian currently (8.3)
    ffmpeg -i "$1" -f mp3 "${1%.*}.mp3"
}

transform-rotate-right () {
    # rotate a photo right 90 degrees
    convert "$1" -rotate 90 "rotate_$1"
}

transform-rotate-180 () {
    # flip a photo 180 degrees
    convert "$1" -rotate 180 "rotate_$1"
}

transform-rotate-left () {
    # rotate a photo left 90 degrees
    convert "$1" -rotate 270 "rotate_$1"
}

serve-here () {
    # serve the current directory here on port 8080
    ifconfig
    python -m SimpleHTTPServer 8080
}

nmap-network () {
    # use nmap to show network interfaces
    nmap --iflist
}

nmap-host-ports () {
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time nmap -v -sT -p 1-65535 "$1"
}

nmap-host-ports-super () {
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time nmap -v -sS -p 1-65535 "$1"
}

nmap-lan () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time nmap -sP 192.168.0-1.0-255
}

nmap-lan-os () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time sudo nmap -sS -O 192.168.0-1.0-255
}

nmap-lan-super () {
    # scan current network, based on common home router addresses,
    # slowly using nmap
    # XXXX: generally takes less than a 10 minutes, or lesss than 10 seconds
    time sudo nmap -sS 192.168.0-1.0-255
}

nmap-lan-complete () {
    # scan current network completely using nmap
    time sudo nmap -sP 192.168.0.0/16
}

nmap-lan-complete-super () {
    # scan current network completely and slowly using nmap
    time sudo nmap -sS 192.168.0.0/16
}

netstat-connections () {
    # check current networking connections
    netstat -untap
}

netstat-connections-super () {
    # check current networking connections
    sudo netstat -untap
}

lpr-double-sided-portrait () {
    # print file as double-sided in portrait mode
    lpr -o sides=two-sided-long-edge "$1"
}

lpr-double-sided-landscape () {
    # print file as double-sided in landscape mode
    lpr -o sides=two-sided-short-edge "$1"
}

ls-sort-date () {
    # ls and sort by reverse date
    ls -ltr
}

need_new_symlink () {
    # create new symlink deleting old symlinks but not old files
    if [[ -e "$2" && ! -h "$2" ]]; then
        # symlink is a file or something
        yell "$2: exists but is not a symlink!!!"
    elif [[ ! -h "$2" ]]; then
        # symlink does not exist at all or is a file
        ln -s "$1" "$2"
    elif [[ -h "$2" && ! -e "$2" ]]; then
        # symlink exists but is invalid
        rm -f "$2"
        ln -s "$1" "$2"
    elif [[ -h "$2" && $(readlink -f "$2") != $(readlink -f "$1") ]]; then
        # symlink exists but points to different location than we are going to
        yell "Symlink $2 exists but points to $(readlink -f "$2") instead of $1!"
    fi
}

# TODO: do something if there is a directory
cp_if_different () {
    # is destination a directory
    if [[ -d "$2" ]]; then
        THEBASENAME=$(basename "$1")
        if ! cmp --silent "$1" "$2"/"$THEBASENAME"; then
            command cp "$1" "$2"
        fi
    else
        if [[ ! -e "$2" ]] || ! cmp --silent "$1" "$2"; then
            command cp "$1" "$2"
        fi
    fi
}

match_string_array () {
    # check if a given string is in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 0; done
    return 1
}

not_match_string_array () {
    # check if a given string is not in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 1; done
    return 0
}

view-def () {
    # view the definition of a bash function
    # TODO: check if it is an alias first
    declare -f "$1"
}

read-file-regexp () {
    # read lines from a file and merge them into a regexp
    local NEWREGEXP=""
    while read line; do
        NEWREGEXP+=$line"|"
    done < "$1"
    echo ${NEWREGEXP::-1}
}

clean-pwd-files-pretend () {
    # see if files in current directory can be renamed to be safe from
    # punctuation and unicode boogeymen
    rename -n "s|'||g" *
    rename -n "s|:||g" *
    rename -n "s|\xe2\x80\x99||g" *
    rename -n "s|\xe2\x80\x93|-|g" *
    rename -n "s|\xe2\x80\x94|-|g" *
    rename -n "s|\xc2\xa1|-|g" *
}

clean-pwd-files () {
    # actually rename files in current directory to be safe from
    # punctuation and unicode boogeymen
    rename "s|'||g" *
    rename "s|:||g" *
    rename "s|\xe2\x80\x99||g" *
    rename "s|\xe2\x80\x93|-|g" *
    rename "s|\xe2\x80\x94|-|g" *
    rename "s|\xc2\xa1|i|g" *
}

psg () {
    if [[ -z "$1" ]]; then
        ps -efj | less
    else
        # TODO: this can be done better!
        ps -efj | head -n 1
        ps -efj | grep -- "$1"
    fi
}

cpu-throttle-up () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "${i}" -g performance
    done
}

cpu-throttle-ondemand () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "${i}" -g ondemand
    done
}

cpu-throttle-down () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "${i}" -g powersave
    done
}

find-broken-symlinks () {
    # find- for useful find command variations
    find . -type l -xtype l
}

xclip-show-all () {
    # TODO: maybe only show extra line if necessary
    h1
    msg "Primary"
    xclip -o -selection p
    echo ""
    h1
    msg "Secondary"
    xclip -o -selection s
    echo ""
    h1
    msg "Clipboard"
    xclip -o -selection c
    echo ""
}

# TODO: pop this up somehow with a key
watch-xclip-show-all () {
    watch -n 1 --color --exec bash -c "source $HOME/.bash_libenv;xclip-show-all"
}

# watch-xclip () {
#     while true; do
#         # calling xclip-show-all does not do as expected
#         h1
#         msg "Primary"
#         xclip -o -selection p
#         h1
#         msg "Secondary"
#         xclip -o -selection s
#         h1
#         msg "Clipboard"
#         xclip -o -selection c
#         sleep 1
#     done
# }

du-sort () {
    # sort by size after using du
    \du --total --summarize --human-readable -- * 2>/dev/null | sort --human-numeric-sort
}

du-sort-dotfiles () {
    du --summarize --human-readable .[^.]* 2>/dev/null | sort --human-numeric-sort
}

du-total-symlink () {
    # sort by size after using du
    du --summarize --total --dereference --human-readable * 2>/dev/null
}

dd-progress () {
    # TODO: spaces after | ???
    #       try on next big dd
    # ps auxww | grep " dd " |grep -v grep |awk '{print $2}' |while read pid; do kill -USR1 $pid; done
    # http://askubuntu.com/questions/215505/how-do-you-monitor-the-progress-of-dd
    sudo kill -USR1 $(pgrep ^dd)
}

youtube-mp3 () {
    # download mp3 from youtube
    youtube-dl --extract-audio -audio-format mp3 "$1"
}

dconf-grep () {
    # grep the GNOME config database
    dconf dump / | grep -i -- "$1"
}

dconf-less () {
    # use less to view the GNOME config database
    dconf dump / | less
}

fdi () {
    # search for file matching first argument in tree
    find . -iname "*${1}*"
}

fgi () {
    if [[ -z "${2}" ]]; then
        find . -type f -exec grep -H --color -n -- "${1}" {}  \;
    else
        find . -type f -iname "*${1}*" -exec grep -H --color -n -- "${2}" {}  \;
    fi
}

harm-bash () {
    fix-gpg-ssh-permissions
    source ${HOME}/.bash_profile
}

harm-bashrc () {
    fix-gpg-ssh-permissions
    source ${HOME}/.bashrc
}

harm-xresources () {
    # reload x-resources for development purposes
    # otherwise it is done in bash-profile....
    if [[ -f "${HOME}/.Xresources" ]]; then
        msg "Loading Xresources!!!"
        xrdb ${HOME}/.Xresources
    fi
}

fix-standard-permissions () {
    true
}

fix-crypt-permissions () {
    # fix the permissions on a cryptography-relevant directory
    if [[ -z "$1" ]]; then
        yell "Must have a file or directory to fix!"
    else
        # fail silently if does not exist
        if [[ -e "$1" ]]; then
            if [[ -d "$1" ]]; then
                chmod --recursive g-rwx "$1"
                chmod --recursive o-rwx "$1"
                chmod u+rwX --recursive "$1"
            else
                chmod g-rwx "$(readlink -f $1)"
                chmod o-rwx "$(readlink -f $1)"
                chmod u+rwX "$(readlink -f $1)"
            fi
        fi
    fi
}

fix-gpg-ssh-permissions () {
    # TODO: start adding things that might be necessary
    # TODO: start adding this to the front of critical operations
    # fix the permissions on the standard gpg and ssh directory
    fix-crypt-permissions "${HOME}"/.gnupg
    fix-crypt-permissions "${HOME}"/.ssh
    fix-crypt-permissions "${HOME}"/.msmtprc
}

backlight-percentage () {
    # XXXX: very device dependent but useful to include, make more general
    echo "`cat /sys/class/backlight/intel_backlight/brightness`*100/`cat /sys/class/backlight/intel_backlight/max_brightness`" | bc -l | xargs printf "%1.0f\n"
}

vcs-check-root () {
    # check if a pull is needed for for child directories if they correspond to common version control systems
    # from https://stackoverflow.com/questions/3258243/git-check-if-pull-needed
    # stop it from running home because that's dumb
    # TODO: other directories
    if [[ ${PWD} == ${HOME} ]]; then
        yell "Cannot run in home directory!!!"
        return 1
    fi
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        # check for various things
        if [[ -d "$dirname/.git" ]]; then
            # TODO: exclude lines saying [up to date] and just give a summary of branches
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            # TODO: why was first git fetch here?
            #       does it stil work the same now?
            # git fetch
            git -c color.ui=always fetch --verbose
            # h2 "diff origin/master"
            # git diff origin/master --summary
            h2 "pull needed?"
            # TODO: indicate no pull needed
            local STATUS=$(git -c color.ui=always status -uno)
            if echo "$STATUS" | grep "up-to-date" >/dev/null; then
                msg "Seems up to date!"
            else
                yell "Not up to date!"
            fi
            echo "$STATUS"
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Checking $dirname/.hg"
            # TODO: non-functional? I have no remaining hg repos
            # pushd . >/dev/null
            # cd "$dirname"
            # hg fetch --dry-run --verbose
            # popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Checking $dirname/.svn"
            pushd . >/dev/null
            cd "$dirname"
            svn status --show-updates
            popd >/dev/null
        else
            h1 "Not checking $dirname"
        fi
    done
}

vcs-update-versions () {
    # TODO: add fences and safeguards
    # TODO: search recursively with find command
    # find . -not -path "*git*" -type f -exec bash -c 'source ~/.bash_libenv;vcs-update-file-version "{}"'  \;
    for f in ${PWD}/*; do
        [[ -f "$f" ]] || continue
        local FILETYPE=$(file -L "$f")
        # if file starts with #!
        if [[ "$(head -n 1 $f)" =~ ^\#! ]]; then
            # hash comment
            sed -i -e "s/^# Version:.*$/# Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if grep -- "^# Copyright" $f >/dev/null && ! grep -- "^# Copyright.*2016" $f >> /dev/null; then
                warn "Need to update year in $f"
            fi
        elif [[ "$FILETYPE" =~ "Lisp/Scheme program" || "$VERSIONFILE" =~ \.el$ ]]; then
            # lisp
            sed -i -e "s/^;; Version:.*$/;; Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if grep -- "^;; Copyright" $f >/dev/null && ! grep -- "Copyright.*2016" $f >> /dev/null; then
                warn "Need to update year in $f"
            fi
        elif [[ "$FILETYPE" =~ "LaTeX document" ]]; then
            # latex
            sed -i -e "s/^% Version:.*$/% Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if ! grep -- "Copyright.*2016" $f >/dev/null; then
                warn "Need to update year in $f"
            fi
        fi
    done
}

fail2ban-check () {
    # check fail2ban status and show number of banned IPs for each date in the past
    sudo zcat /var/log/auth.log*.gz | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    # a hack to find non-gz logs
    sudo cat /var/log/auth.lo*[^z] | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    sudo fail2ban-client status ssh
    sudo fail2ban-client status ssh-root
}

drop-caches () {
    su -c "free && sync && echo 3 > /proc/sys/vm/drop_caches && free"
}

mount-disk-uuid () {
    # find mounted disk or ???
    local UUID="$1"
    # allow full UUID path to be given
    if [[ "$UUID" == /dev/disk/by-uuid/* ]]; then
        local UUIDDEVICE="$(readlink -f ${UUID})"
    else
        local UUIDDEVICE="$(readlink -f /dev/disk/by-uuid/${UUID})"
    fi
    if grep -qs -- "$UUIDDEVICE" /etc/mtab; then
        echo -e $(grep -- ^"${UUIDDEVICE}[[:space:]]\+" /etc/mtab | cut -d ' ' -f 2)
        return 0
    else
        # TODO: for now I have gnome mount for me but would like to change this
        yell "Disk not mounted!!!"
        return 1
        # # TODO: mount on a temporary directory
        # MOUNTPOINT=$(mktemp -d)
        # sudo mount "${IDDEVICE}" "${MOUNTPOINT}"
        # echo "${MOUNTPOINT}"
    fi
}

device-disk-uuid () {
    # find mounted disk or ???
    local UUID="$1"
    local UUIDDEVICE="$(readlink -f /dev/disk/by-uuid/${UUID})"
    echo ${UUIDDEVICE}
}

vcs-diff-public () {
    # diff the "master" with the "public" branch for current directory or all child directories that are git repositories
    # XXXX: git only for now
    if [[ -d "${PWD}/.git" ]]; then
        git diff public..master
    else
        for dirname in ${PWD}/*; do
            if [[ -d "$dirname/.git" ]]; then
                pushd . >/dev/null
                cd "$dirname"
                if git rev-parse --verify public &>/dev/null; then
                    h1 "Checking $dirname"
                    git diff master..public --stat
                fi
                popd >/dev/null
            fi
        done
    fi
}

vcs-push-github () {
    # merge public branch and commit to github
    # XXXX: repository must be setup properly
    # TODO: update verions and commit
    # TODO: this probably only works because I use controlmaster
    #       second ssh to git@github.com does not work alone, the pipe makes it freeze
    ssh-batch -T git@github.com &>/dev/null
    if ! ssh-batch -T git@github.com 2>&1 | grep --color=never "success"; then
        yell "Error connecting to github! Aborting!"
        return 1
    fi
    if ! git -c color.ui=always checkout public; then
        yell "Checkout of public unsuccessful!"
        return 1
    fi
    # test the connection before doing any funny business
    # TODO: is this safe?
    git -c color.ui=always merge --squash -X theirs master --stat --allow-unrelated-histories
    local COMMITCORRECT=n
    while [[ "$COMMITCORRECT" != "y" ]]; do
        while read -r -t 0;do read -r; done;
        read -e -p "Enter commit message: " COMMITMESSAGE
        # TODO: add option for quit
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Use commit message (y/n/q)? " COMMITCORRECT
        echo ""
        if [[ "$COMMITCORRECT" == "q" ]]; then
            yell "Aborting!"
            git -c color.ui=always checkout master
            return 1
        fi
    done
    git -c color.ui=always commit -a -m "$COMMITMESSAGE"
    # TODO: eventually go "public" locally to "master" globally
    git -c color.ui=always push --force --set-upstream github public:master
    git checkout master
}

vcs-conflicts () {
    # TODO: expand at some point
    git diff --name-only --diff-filter=U
}

alias dkpg-purge-all='master-dpkg-purge-all'
master-dpkg-purge-all () {
    # purge all files related to uninstalled packages
    if dangerous-function-ask; then
        dpkg -l | grep ^rc | cut -d' ' -f3|xargs sudo dpkg -P
    fi
}

git-serve () {
    # a convienient command to browse code for now
    git instaweb
}

harm-id3-audiobook-all () {
    # set up all audiobooks in immediate subdirectories for my player
    # (after appropriate file renaming)
    if dangerous-function-ask; then
        for d in ${PWD}/*; do
            [[ -d "$d" ]] || continue
            pushd . >/dev/null
            cd "${d}"
            yes | harm-id3-genre-as-audiobook
            yes | harm-id3-album-as-directory
            yes | harm-id3-name-as-filename
            yes | harm-id3-alphabetical-track
            yes | harm-id3-remove-v1
            popd >/dev/null
        done
    fi
}

harm-id3-genre-as-audiobook () {
    # set genre of all .mp3 as audiobook
    if dangerous-function-ask; then
        eyeD3 --to-v2.4 --genre="Audiobook" *.mp3
    fi
}

harm-id3-name-as-filename () {
    # make track name correspond to filename
    if dangerous-function-ask; then
        for F in ${PWD}/*.mp3; do
            local BNAME="${f%%.mp3}"
            # XXXX: basename doesn't work with comma in filename
            local BNAME="${bname##*/}"
            eyeD3 --to-v2.4 --title="$BNAME" "$F"
        done
    fi
}

harm-id3-alphabetical-track () {
    # number tracks based on the alphabetical sort order
    if dangerous-function-ask; then
        # totals cause confusion
        eyeD3 --track-total=0 *.mp3
        local COUNT=1
        for F in ${PWD}/*.mp3; do
            eyeD3 --to-v2.4 --track=$(printf "%03d\n" $COUNT) "$F"
            let COUNT+=1
        done
    fi
}

harm-id3-album-as-directory () {
    # use directory name for album name as all tracks
    if dangerous-function-ask; then
        local ALBUM=$(basename "${PWD}")
        eyeD3 --to-v2.4 --album "$ALBUM" *.mp3
    fi
}

harm-id3-remove-v1 () {
    # remove v1 id3 tags because they interfere with some players
    if dangerous-function-ask; then
        eyeD3 --remove-v1 *.mp3
    fi
}

ls-id3 () {
    # list id3 tags of all mp3s in directory
    eyeD3 *.mp3
}

ag-list-doc () {
    apt-cache search . | grep -- "\-doc " | cut -d' ' -f1
}

ag-list-packages-only () {
    ag-list-installed | cut -d' ' -f3
}


# the three-fingered claw, see https://stackoverflow.com/questions/1378274/in-a-bash-script-how-can-i-exit-the-entire-script-if-a-certain-condition-occurs
yell () {
    local NEWCOM=$(echo "$0" | sed -r 's|'"${HOME}"'|~|g')
    echo -e "${BRed}$NEWCOM${Red}: $*${Color_Off}" >&2
}

die () {
    yell "$*"; exit 111
}

try () {
    "$@" || die "cannot $*"
}

warn () {
    # XXXX: not good because it starts up a new command, but avoids escaping slashes
    local NEWCOM=$(echo "$0" | sed -r 's|'"${HOME}"'|~|g')
    echo -e "${BYellow}$NEWCOM${Yellow}: $*${Color_Off}" >&2
}

msg () {
    local NEWCOM=$(echo "$0" | sed -r 's|'"${HOME}"'|~|g')
    echo -e "${BGreen}$NEWCOM${Green}: $*${Color_Off}" >&2
}

h1 () {
    if [[ -z "$*" ]]; then
        local OUTSTR=$(echo "================================================================================" | cut -c 1-80)
    else
        local OUTSTR=$(echo "==== $* ================================================================================" | cut -c 1-80)
    fi
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-end () {
    if [[ -z "$*" ]]; then
        local OUTSTR=$(echo "" | cut -c 1-80)
    else
        local OUTSTR=$(echo "$*" | cut -c 1-80)
    fi
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h1-script () {
    local OUTSTR=$(echo "==== Running $(basename $0) ================================================================================" | cut -c 1-80)
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-script-end () {
    local OUTSTR=$(echo "Finishing $(basename $0)" | cut -c 1-80)
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h2 () {
   if [[ -z "$*" ]]
    then
        local OUTSTR=$(echo "----------------------------------------" | cut -c 1-60)
    else
        local OUTSTR=$(echo "---- $* ----------------------------------------" | cut -c 1-60)
   fi
   # TODO: probably want different color than cyan
   echo -e "${BWhite}${On_Cyan}$OUTSTR${Color_Off}" >&2
}

h3 () {
   if [[ -z "$*" ]]
    then
        local OUTSTR=$(echo "----")
    else
        local OUTSTR=$(echo "---- $*")
    fi
    echo -e "${White}${On_Purple}$OUTSTR${Color_Off}" >&2
}

git-ls () {
    git ls-tree -r master --name-only
}

test-all-colors () {
    # http://askubuntu.com/questions/27314/script-to-display-all-terminal-colors
    for x in 0 1 4 5 7 8; do for i in `seq 30 37`; do for a in `seq 40 47`; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo "";
}

aloopback () {
    arecord -vv | sox -t wav - -t wav - highpass 300 | aplay
}

aloopback-high () {
    arecord -vv | sox -t wav - -t wav - highpass 300 | aplay
}

aloopback-low () {
    arecord -vv | sox -t wav - -t wav - lowpass 300 | aplay
}

vcs-init-full () {
    # TODO: check for files existing
    git init && git add * && git commit -a -m 'initial commit'
}

check-emacs-daemon () {
    ps -ef | grep -- "emacs --daemon" | grep -v grep >/dev/null
    return $?
}

check-chromium () {
    ps -ef | grep "/usr/lib/chromium/chromium" | grep -v grep >/dev/null
    return $?
}

check-firefox () {
    ps -ef | grep "firefox\|iceweasel" | grep -v grep >/dev/null
    return $?
}

disk-info () {
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo smartctl -A "$1"
    fi
}

monitor-disks () {
    disk-info /dev/sda
    disk-info /dev/sdb
    disk-info /dev/sdc
    disk-info /dev/sdd
    disk-info /dev/sde
    disk-info /dev/sdf
}


disk-temp () {
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo hddtemp "$1"
        sudo smartctl -A "$1" | grep -i temperature
    fi
}

monitor-disk-temp () {
    disk-temp /dev/sda
    disk-temp /dev/sdb
    disk-temp /dev/sdc
    disk-temp /dev/sdd
    disk-temp /dev/sde
    disk-temp /dev/sdf
}

monitor-disk-speed () {
    # https://www.webhostingtalk.com/showthread.php?t=906573
    # http://www.yasith.info/2010/01/how-to-check-hard-disk-performance-and.html
    sudo hdparm -tT /dev/"$1"
}

fix-permissive-permissions () {
    if [[ -e "$1" ]]; then
        chmod 755 "$1"
    fi
}

fix-permissive-permissions-recursive () {
    if [[ -d "$1" ]]; then
        chmod -R 755 "$1"
    fi
}

add-line-if-not-exist () {
    local THEFILE="$1"
    local NEWLINE="$2"
    grep -q -F -- "${NEWLINE}" "${THEFILE}" || echo "$NEWLINE" >> "$THEFILE"
}

kill-blank-lines () {
    sed -n -e '/^\s*$/d' "$1"
}

screen-select () {
    # TODO: do I want letters instead???
    local SCREENSESSIONS=$(screen -ls | grep pts | cut -f1 -d"." | sed -e 's/^[[:space:]]*//g')
    if [[ -n "$SCREENSESSIONS" ]]; then
        #Set the field separator to new line
        IFS=$'\n'
        #Try to iterate over each line
        local count=1
        for item in $SCREENSESSIONS; do
            echo "$count) $item"
            local count=$(( $count + 1 ))
        done
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Enter the screen session: " SCREENSELECT
        echo ""
        screen -dr $(sed -n "${SCREENSELECT}"p <<< "${SCREENSESSIONS}")
    else
        false
    fi
}

sage-notebook () {
    # open a Sage notebook and browser securely on port 18080
    # XXXX: requires defining of ${PYTHON_NOTEBOOK_ROOT} before calling, do I want this for sage.... fix...
    # TODO: JUPYTER_NOTEBOOK_ROOT is forward-looking...
    if [[ -n "${JUPYTER_NOTEBOOK_ROOT}" ]]; then
        # TODO: do I still need this?
        bleachbit --overwrite --clean epiphany.* google_chrome.*
        local NBPATH="${JUPYTER_NOTEBOOK_ROOT}/sage-notebooks-${HOSTNAME}.sagenb"
        mkdir -p "${NBPATH}"
        # XXXX: grep to avoid just sage-notebook from scripts that might run this
        if ps -ef | grep "src/bin/sage-notebook" | grep -v grep >/dev/null; then
            sage-notebook-browser
            return 255
        else
            # TODO: select firefox and chromium?
            SAGE_BROWSER="nohup firefox -P sagenotebook" sage --notebook=sagenb secure=True port=18080 automatic_login=True interface='' directory="${NBPATH}"
            # SAGE_BROWSER="nohup chromium" sage --notebook=sagenb secure=True port=18080 automatic_login=True interface='' directory="${NBPATH}"
            return 0
        fi
    else
        yell 'JUPYTER_NOTEBOOK_ROOT not defined!!!'
    fi
}

# TODO: support multiple browsers?
sage-notebook-browser () {
    # open just the browser for a running Sage notebook
    if false; then
        bleachbit --overwrite --clean google_chrome.*
        chromium https://localhost:18080/ &>/dev/null &
    else
        # TODO: shred firefox if not running
        nohup firefox -P sagenotebook https://localhost:18080/ &>/dev/null &
    fi
}

sage-jupyter-notebook () {
    # open an iPython notebook and browser using the Sage platorm on port 18888
    # TODO: need to control where goes
    # XXXX: requires defining of ${PYTHON_NOTEBOOK_ROOT} before calling
    if [[ -n "${JUPYTER_NOTEBOOK_ROOT}" ]]; then
        bleachbit --overwrite --clean epiphany.* google_chrome.*
        # set a good directory for these
        local NBPATH="${JUPYTER_NOTEBOOK_ROOT}/sage-jupyter-projects"
        mkdir -p "${NBPATH}"
        # TODO: subsitute for --deep-reload --automagic --secure --pprint depricated options
        if ps -ef | grep -- "--notebook=jupyter" | grep -v grep >/dev/null; then
            sage-jupyter-notebook-browser
        else
            sage --notebook=jupyter --notebook-dir="${NBPATH}" --browser="firefox -P default" --port=18888
        fi
    else
        yell '${PYTHON_NOTEBOOK_ROOT} not defined!!!'
    fi
}

# TODO: support multiple browsers?
sage-jupyter-notebook-browser () {
    # open just the browser for a running iPython notebook
    bleachbit --overwrite --clean epiphany.* google_chrome.*
    firefox -P default http://localhost:18888/
}

file-mimetype () {
    # quick way to get mimetype
    file --mime-type "$1"
}

ssh-scs () {
    # XXXX: this one autodetaches after exit from screen session
    ssh "$@" -t "bash --rcfile ~/.bash_libenv -li -c \"screen-select\""
    # XXXX: this one stays attached after exit from screen session
    # ssh "$@" -t "bash --rcfile ~/.bash_libenv -li -c \"screen-select;/bin/bash\""
}

# TODO: move these out

youtube-previous () {
    # global function to see previous video in youtube playlist
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep -- "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}";
            xdotool windowactivate --sync "${line}"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.1
            conkeror-batch -f youtube-previous
        fi
    done
    # TODO: very arbitrary, perhaps wait for something to return
    sleep 0.5
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

youtube-next () {
    # global function to see previous video in youtube playlist
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep -- "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.1
            conkeror-batch -f youtube-next
        fi
    done
    # TODO: very arbitrary delay, perhaps wait for something to return
    sleep 0.5
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

# master-boss-key () {
#     # get current window
#     local CURRENTWINDOW=$(xdotool getwindowfocus)
#     local CURRENTWINDOWNAME=$(xdotool getwindowname ${CURRENTWINDOW})
#     # kill volume
#     amixer set Master mute
#     # https://askubuntu.com/questions/26068/how-do-you-mute-from-the-command-line
#     # amixer -c 0 set Master playback 0% mute
#     # minimize browser windows, do they ever not have their name in title?
#     # TODO: remove from taskbar
#     # TODO: try out with windowclass too
#     xdotool search --onlyvisible --name conkeror | while IFS= read -r line; do
#         xdotool windowminimize "${line}"
#     done
#     xdotool search --onlyvisible --name firefox | while IFS= read -r line; do
#         xdotool windowminimize "${line}"
#     done
#     # turn off youtube
#     xdotool search --name youtube | while IFS= read -r line; do
#         if xdotool search --class conkeror | grep -- "${line}" >/dev/null; then
#             xdotool windowfocus --sync "${line}";
#             sleep 0.05
#             conkeror-batch -f youtube-pause
#         fi
#     done
#     # restore focus, but make sure its not browser window
#     [[ ! "${CURRENTWINDOWNAME,,}" =~ conkeror && ! "${CURRENTWINDOWNAME,,}" =~ firefox ]] && xdotool windowactivate --sync ${CURRENTWINDOW}
# }

master-unboss-key () {
    # kill volume
    amixer set Master unmute
    # TODO: restore youtube
    # unminimize all windows
    # TODO: use xdotool to restore instead?
    # TODO: at least add back to taskbar
    # wmctrl -r conkeror  -b remove,shaded,skip_taskbar
    # wmctrl -r firefox   -b remove,shaded,skip_taskbar
    # wmctrl -r remove   -b remove,shaded,skip_taskbar
}

focus-emacs-window () {
    # TODO: do something a little nicer, maybe use xdotool
    wmctrl -x -a emacs.Emacs
}

################################################################################
## enumerate things like block devices

enumerate-physical-disks () {
    # find all physical disks
    # TODO: will likely need to be improved for all appropriate uses
    for d in /dev/sd*; do
        [[ -b "$d" && ! "$d" =~ .*[[:digit:]] ]] || continue
        echo "$d"
    done
}

enumerate-crypt-disks () {
    # find all decrypted block devices
    # TODO: will likely need to be improved for all appropriate uses
    for d in /dev/mapper/crypt--*; do
        [[ -b "$d" ]] || continue
        echo "$d"
    done
}

df-crypt-disks () {
    # get information on decrypted block devices
    df -h $(enumerate-crypt-disks)
}

smartctl-disks () {
    # check overall health of all disks
    for d in $(enumerate-physical-disks); do
        local SMARTOUTPUT=$(sudo smartctl -H "$d")
        if [[ $(($? & 1)) ]]; then
            echo -n "$d: "
            # XXXX: to use this in scripts I have to add smartctl to no password sudo files
            echo "$SMARTOUTPUT" | grep --color=never "overall-health"
        fi
    done
}

smartctl-disks-errors () {
    # check overall health of all disks
    # TODO: current powered up time
    for d in $(enumerate-physical-disks); do
        h2 "$d"
        local POWERONHOURS=$(sudo smartctl -A "$d" | grep Power_On_Hours)
        local SMARTOUTPUT=$(sudo smartctl --log=error "$d")
        if [[ $(($? & 1)) ]]; then
            echo -n "$d: "
            # XXXX: to use this in scripts I have to add smartctl to no password sudo files
            echo "$POWERONHOURS"
            echo "$SMARTOUTPUT"
        fi
    done
}

select-disk-uuid-usb () {
    # select a usb disk by UUID or alternately any other mounted drive
    # XXXX: doesn't work with more than 9 drives, but could be fixed
    # TODO: are usb always in UUID?
    #       "$1" gives default
    # create array
    local USBARRAY=()
    if [[ -n "$1" ]]; then
        if [[ -e /dev/disk/by-uuid/"$1" ]]; then
            if grep -qs -- $(readlink -f /dev/disk/by-uuid/"$1") /proc/mounts; then
                echo "0) $1 (default, mounted)" >&2
            else
                echo "0) $1 (default, not mounted)" >&2
            fi
        else
            echo "0) $1 (default, not found)" >&2
        fi
    fi
    local count=1
    for d in /dev/disk/by-uuid/*; do
        [[ "$d" == "/dev/disk/by-uuid/$1" ]] && continue
        if /sbin/udevadm info --query=all --name=$(readlink -f $d) | grep ID_BUS >/dev/null; then
            printf "$count) %-55s  %s\n" "$d" "$(df -H $d | grep -v ^Filesystem)"
            local count=$(( $count + 1 ))
            USBARRAY+=("$d")
        fi
    done
    echo "$count) Non-USB drive" >&2
    echo "-) Cancel" >&2
    while read -r -t 0;do read -r; done;
    read -n 1 -p "Enter the USB drive: " USBSELECT >&2
    echo "" >&2
    if [[ $USBSELECT == "-" ]]; then
        echo "Canceled!" >&2
        return 1
    fi
    # TODO: remove home and root mount once I test more, these will almost never be the right answer
    local count=1
    if [[ $USBSELECT == "0" && -n "$1" ]]; then
        echo "/dev/disk/by-uuid/$1"
        return 0
    elif [[ $USBSELECT == "$count" ]]; then
        echo "Non-USB alternate!" >&2
        IFS=$(echo -en "\n\b")
        local ALTERNATEARRAY=()
        local count=1

        for a in $(df | grep -v "udev\|tmpfs\|^Filesystem"); do
            echo "$count) $a" >&2
            ALTERNATEARRAY+=("$a")
            local count=$(( $count + 1 ))
        done
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Enter an alternate drive: " ALTERNATESELECT >&2
        echo "" >&2
        if [[ $ALTERNATESELECT == "0" || ! $ALTERNATESELECT =~ ^[0-9]+$ ]] || (( $ALTERNATESELECT >= $count )); then
            return 1
        fi
        local ALTERNATESELECT=$(( $ALTERNATESELECT - 1 ))
        # XXXX: get first column because we use df for this
        echo ${ALTERNATEARRAY[$ALTERNATESELECT]} | cut -d' ' -f1
        return 0
    fi
    if ! [[ $USBSELECT =~ ^[0-9]$ ]] || (( $USBSELECT >= $count )); then
        return 1
    fi
    local USBSELECT=$(( $USBSELECT - 1 ))
    # TODO: keep ensuring only proper thing is every returned, avoid use of tail
    echo ${USBARRAY[$USBSELECT]}
    return 0
}

# TODO: helper function to query physical disk info.... but only works for unencrypted
# TODO: query only USB
# TODO: keep finding parent disk
# TODO: lsblk may be best, but this shows what is needed for select-disk-uuid-??? functions
select-disk-uuid-info () {
    # TODO: need columns
    echo "ID: "
    for d in /dev/disk/by-id/*; do
        echo "$d: $(readlink -f $d) $(/sbin/udevadm info --query=all --name=$(readlink -f $d) | grep ID_BUS)"
    done
    echo ""
    echo "UUID: "
    for d in /dev/disk/by-uuid/*; do
        echo "$d: $(readlink -f $d) $(/sbin/udevadm info --query=all --name=$(readlink -f $d) | grep ID_BUS)"
    done
}

dangerous-function-ask () {
    while read -r -t 0;do read -r; done;
    read -n 1 -p "Dangerous function! Continue (y/n)? " YN
    echo ""
    if [[ "$YN" == "y" ]]; then
        true
    else
        false
    fi
}

continue-ask () {
    while read -r -t 0;do read -r; done;
    read -n 1 -p "Continue (y/n)? " YN
    echo ""
    if [[ "$YN" == "y" ]]; then
        true
    else
        false
    fi
}

vcs-grep-conflicted () {
    # find git conflicted markers in current directory tree
    # TODO: proper return values?
    # TODO: avoid running /home or above... takes way too long!
    find . -not -path "*.git*" -type f -exec grep -nH --color -- "^<<<<<<< \|^>>>>>>> \|^=======$\|^####### " {} \;
}

# TODO: broken, rfigure out if I can remove
# flashplayer-update () {
#     sudo update-flashplugin-nonfree --install --verbose
# }

mdstat-status () {
    local MDSTAT="$(cat /proc/mdstat | sed -n '/^md\|^[[:space:]]*\[\|blocks/p')"
    local FIRST=1
    IFS=$'\n'
    for i in $(echo "${MDSTAT}"); do
        if [[ "$i" =~ ^m.* ]]; then
            printf "$i"
        else
            local SELECTED=$(echo "$i" | grep --color=never -Eo -- "\[[A-Za-z]*\]$")
            if [[ -n "$SELECTED" ]]; then
                echo " $SELECTED"
            fi
        fi
    done
}

repl-restartable () {
    # restart a repl over and over again if desired
    local TRYAGAIN=" "
    while [[ "${TRYAGAIN}" == " " ]]; do
        ($@)
        local RETURNVALUE=$?
        echo "repl-restartable return code: $RETURNVALUE"
        if [[ "$RETURNVALUE" == 255 ]]; then
            # TODO: better return values than this?
            return 255
        fi
        while read -r -t 0;do read -r; done;
        IFS= read -n 1 -s -p 'Press [Enter] to exit or [Space] to restart...' TRYAGAIN
        if [[ "${TRYAGAIN}" == " " ]]; then
            reset
        fi
    done
    return 0
}

vcs-attr () {
    # https://stackoverflow.com/questions/6855712/why-does-git-treat-this-text-file-as-a-binary-file
    # check attributes
    git check-attr --all -- "$1"
}

################################################################################
## genric download for Canada NTS topo maps
## good scripts for slurping data from other ftp websites

wget-download-canmatrix2-doc () {
    local NEWDIR="/mnt-secondary/"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=300 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/doc/
    popd >/dev/null
}

wget-download-canmatrix2-50k-preview () {
    local NEWDIR="/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    popd >/dev/null
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/50k/
}

wget-download-canmatrix2-250k-preview () {
    local NEWDIR="/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    popd >/dev/null
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/250k/
}

wget-download-canmatrix2 () {
    local NEWDIR="/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    # TODO: need an alias for this type of download
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      "$1"
    popd >/dev/null
}

# TODO: this can be a lot better at some point
wget-current-canmatrix () {
    # expect to take about 16*((16 * 12) + 60) per large grid = 4032min per large numbered grid
    # generally run this on my server to an external hard drive at ~/mnt
    local URLS=("ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/50k_tif/104/p")
    if ! type send-returncode-mail >/dev/null; then
        warn "No text message progress reports, send-returncode-mail function not configured."
        alias send-returncode-mail="false"
    else
        true
        send-returncode-mail "Canmatrix- starting!"
    fi
    if grep -qs /mnt-secondary /proc/self/mounts >/dev/null; then
        {
            time {
                pushd . >/dev/null
                cd /mnt-secondary
                # 83 urls, area around edmonton
                h1 "Starting!!!"
                for URL in "${URLS[@]}"; do
                    h2 "Next!!!"
                    h3 "$URL"
                    wget-download-canmatrix2 "$URL"
                    # TODO: fix this, probably by aliasing send-returncode-mail to false if not exist
                    send-returncode-mail "Canmatrix- done another grid!" "$URL"
                    sleep $(( $RANDOM % 60 + 30 ))m
                    # test code
                    # echo "$URL"
                    # sleep $(( $RANDOM % 60 + 30 ))s
                done
                popd >/dev/null
            }
        } 2>&1 | tee -a /mnt-secondary/canmatrix2-$(date-time-stamp).log
        send-returncode-mail "Canmatrix- done grid script!"
    else
        yell "Nothing mounted to collect data!!!"
    fi
}

add-timestamp-head-of-all-files () {
    for f in ${PWD}/*; do
        [[ -f "$f" ]] || continue
        [[ ! "$(basename $f)" =~ [0-9]{14}--.* ]] || continue
        echo "Moving $(basename $f)"
        mv "$(basename $f)" "$(stat $(basename $f) | grep Modify: | sed -e 's/Modify: //' | sed -e 's/-//g' | sed -e 's/://g' | sed -e 's/\..*//g' | sed -e 's/ //g')--$(basename $f)"
    done
}

read-mail () {
    less /var/spool/mail/${USERNAME}
}

gpg-decrypt () {
    gpg-batch --decrypt "$1" 2>/dev/null
}

svg2png-hq () {
    if [[ -z "$1" ]]; then
        yell "No input!"
        return 1
    fi
    local OUTPUT="${1%%.svg}.png"
    if [[ -f "$OUTPUT" ]]; then
        yell "Output $OUTPUT already exists!!!"
        return 1
    else
        convert -density 300 -resize 2000x "$1" "$OUTPUT"
    fi
}

function ls-cron () {
    crontab -u ${USERNAME} -l
}

function ag-rdep () {
    apt-cache rdepends "$1"
}

function ag-rdep-installed () {
    apt-cache rdepends "$1" --installed
}

function ls-mime-files () {
    # list mime settings
    # https://wiki.archlinux.org/index.php/default_applications
    local THEFILES=("$HOME/.config/$desktop-mimeapps.list" "$HOME/.config/mimeapps.list" "/etc/xdg/mimeapps.list" "$HOME/.local/share/applications/mimeapps.list" "/usr/local/share/applications/mimeapps.list" "/usr/share/applications/mimeapps.list")
    for f in ${THEFILES[@]}; do
        if [[ -e "$f" ]]; then
            h3 "$f"
            cat "$f"
        else
            warn "$f not exist!"
        fi
    done

}

function ls-mime-files2 () {
    # see https://unix.stackexchange.com/questions/36380/how-to-properly-and-easy-configure-xdg-open-without-any-enviroment
    # XXXX: changed variable from dd, bad name for bash variable
    for thedir in /usr/share/applications "${HOME}"/.local/share/applications; do
        h2 "$thedir"
        for thefile in $(ls $thedir 2>/dev/null | grep "\\.desktop$"); do
            h3 "$thefile"
            for m in $(grep MimeType $thedir/$thefile | cut -d= -f2 | tr ";" " "); do
                echo xdg-mime default $thefile $m;
            done;
        done;
    done
}

fetch-build-sage-nice () {
    /usr/bin/nice --adjustment 20 /usr/bin/ionice -c3 fetch-build-sage
}

# TODO: reverse these...
fetch-build-sage () {
    # fetch and compile current version of sage
    # usage: use --finalize to finalize the setup
    # XXXX: need to set sage variables elsewhere
    # TODO: check for valid installation
    if [[ -z "$SAGEVERSION" || -z "$SAGEVERSIONMD5" ]]; then
        msg "Using default sage versions."
        # update for every new sage
        local SAGEVERSION="8.0"
        local SAGEVERSIONMD5="93bdd128991e9144c4b137d3d6655065"
        local SAGEMIRROR="http://www.cecm.sfu.ca/sage/src/"
        # TODO: put this somewhere else
        local SAGELOCATION=${HOME}/cic-small/distfiles-current
    fi
    if [[ -d /opt/sage-"$SAGEVERSION" && $@ != *"--finalize"* ]]; then
        if /opt/sage-"$SAGEVERSION"/sage --version; then
            warn "/opt/sage-$SAGEVERSION already present and appears functional."
        else
            yell "/opt/sage-$SAGEVERSION present but appears non-functional."
        fi
        return 1
    fi
    sudo true || return 1
    if [[ $@ != *"--finalize"* ]]; then
        sudo apt-get update
        sudo apt-get install gnutls-bin gnutls-doc libssl1.0.0 libssl-dev libssl-doc libcurl4-gnutls-dev libgnutls28-dev
        sudo apt-get install texlive dvipng ImageMagick
        if [[ -e "${SAGELOCATION}"/sage-"$SAGEVERSION".tar.gz ]]; then
            pushd . >/dev/null
            cd "${SAGELOCATION}"
            msg "Already found in distfiles location!"
        else
            # TODO: put into ~/tmp for more universal use
            # TODO: proper error message if md5sum is not good
            if [[ ! -e "${HOME}"/cic-var/sage-download/sage-"${SAGEVERSION}".tar.gz || ! $(md5sum "${HOME}"/tmp/sage-download/sage-"${SAGEVERSION}".tar.gz | cut -d' ' -f1) == "${SAGEVERSIONMD5}" ]]; then
                msg "Downloading sagemath!"
                if [[ -e "${HOME}"/cic-var/sage-download ]]; then
                    rm -rf "${HOME}"/cic-var/sage-download
                fi
                mkdir -p "${HOME}"/cic-var/sage-download
                pushd . >/dev/null
                cd "${HOME}"/cic-var/sage-download
                # should I delete this?
                # TODO: does the tarball already exist?
                #       do not delete directory in this case
                wget "$SAGEMIRROR"/sage-"${SAGEVERSION}".tar.gz .
                msg "Finished downloading!"
            else
                msg "Sagemath already downloaded!"
                pushd . >/dev/null
                cd "${HOME}"/cic-var/sage-download
            fi
        fi
        MD5SUMCURRENT=$(md5sum sage-"$SAGEVERSION".tar.gz | cut -d' ' -f1)
        echo "\"$MD5SUMCURRENT\" should be \"$SAGEVERSIONMD5\""
        if [[ "$MD5SUMCURRENT" != "$SAGEVERSIONMD5" ]]; then
            yell "md5 sum incorrect!"
            return 1
        fi
        msg "md5 sum correct!"
        msg "Unpacking!"
        if [[ -d sage-"${SAGEVERSION}" ]]; then
            rm -rf sage-"${SAGEVERSION}"
        fi
        tar xvzf sage-"${SAGEVERSION}".tar.gz
        # check installation
        msg "Must now move installation directory to /opt"
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Continue with build (y/n)? " yn
        echo ""
        if [[ "$yn" == "y" ]]; then
            sudo mv ./sage-"${SAGEVERSION}" /opt
            cd /opt/sage-"${SAGEVERSION}"
        else
            return 1
        fi
        # make sure I don't overload my crappy vunerable portable computers
        if [[ "${HOSTNAME}" =~ laptop || "$HOSTNAME" =~ netbook ]]; then
            MAKE='make -j1' time make
        else
            MAKE='make -j8' time make
        fi
        # TODO: option to just finalize
        while read -r -t 0;do read -r; done;
        read -n 1 -p "Build OK and finalize setup? (y/n)? " yn2
        echo ""
    else
        local yn2="y"
        pushd . >/dev/null
        cd /opt/sage-"${SAGEVERSION}"
    fi
    # TODO: make sure I can rerun this if necesssary
    # TODO: make an upgrade, find out if this does not work, make sure it does
    # TODO: possibly upgrade twisted
    if [[ "$yn2" == "y" ]]; then
        msg "Exit sage when done!"
        ./sage
        # build packages
        fetch-build-sage-packages
        # make docs
        make doc
        # TODO: overwrite binary, but ask first
        if [[ -e /usr/local/bin/sage ]]; then
            sudo rm /usr/local/bin/sage
        fi
        sudo ln -s /opt/sage-"${SAGEVERSION}"/sage /usr/local/bin
    else
        echo "Not finalizing!  Can be done later with --finalize"
        return 1
    fi
    # try running sage
    msg "Exit sage when done!"
    ./sage
    msg "Installation done!"
    popd >/dev/null
}

fetch-build-sage-packages () {
    # be in sage directory, the ./sage is safety for this
    # http://doc.sagemath.org/html/en/reference/misc/sage/misc/package.html
    ./sage -i openssl
    ./sage -pip install --upgrade pip
    ./sage -pip install --upgrade service_identity
    ./sage -pip install --upgrade dill
    ./sage -pip install --upgrade lxml
    ./sage -pip install --upgrade multiprocess
    # out of date pillow has been an issue for me before
    ./sage -pip install --upgrade pillow
    ./sage -pip install --upgrade psycopg2
    ./sage -pip install --upgrade pycurl
    ./sage -pip install --upgrade pyopenssl
    # ./sage -pip install --upgrade rlipython
    ./sage -pip install --upgrade readline
    # install sage mode
    # TODO: remove, does not seem to exist, try melpa
    # ./sage -i sage_mode
    # TODO: I can replace most of my keys now
    # echo "Setting up rlipython!"
    # ./sage -ipython -c "import rlipython;rlipython.install()"
}

caps-toggle () {
    # toggle caps just in case
    xdotool key Caps_Lock
}

view-mail () {
    tail -n 200 /var/spool/mail/${USERNAME}
}

srvg () {
    if [[ -z "$1" ]]; then
        service --status-all
    else
        service --status-all | grep -- "$1"
    fi
}

srvr () {
    sudo service "$1" restart
}

srvs () {
    sudo service "$1" status
}

flatten-current-directory () {
    if [[ $@ != *"--for-real"* ]]; then
        find . -mindepth 2 -type f -exec mv {} .
    else
        yell "Dangerous function!!! Use --for-real!!!"
    fi
}

dunst-notifications () {
    printf "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    grep "summary: \|body: " "${HOME}"/tmp/dunst-current.log | grep -v \'\' | sed -e 's/^[ \t]*//' | sed -e 's/body: /    /' | sed -e 's/summary: //'
}

build-install-software () {
    # TODO: add some checks and warnings if things are not present
    pushd . >/dev/null
    cd "${HOME}"/cic-external-vcs
    # assumes I'm in directory with appropriate subdirectories
    # TODO: compile against downloaded poppler
    sudo true || return 1
    # at least for now, download and build a few select pieces of software
    # TODO: evantually make this the only one
    [[ ! -d "${HOME}"/cic-external-vcs ]] && mkdir -p "${HOME}"/cic-external-vcs
    cd "${HOME}"/cic-external-vcs
    # TODO: update this as something better and potentially less destructive
    [[ ! -d "${HOME}"/cic-external-vcs/conkeror-external ]]             && git clone git://repo.or.cz/conkeror.git                     conkeror-external
    [[ ! -d "${HOME}"/cic-external-vcs/urxvt-perls-external ]]          && git clone https://github.com/akroshko/urxvt-perls.git       urxvt-perls-external
    [[ ! -d "${HOME}"/cic-external-vcs/feh-external ]]                  && git clone https://git.finalrewind.org/feh                   feh-exteneral
    [[ ! -d "${HOME}"/cic-external-vcs/girara-external ]]               && git clone https://git.pwmt.org/pwmt/girara.git              girara-external
    [[ ! -d "${HOME}"/cic-external-vcs/PCSX-Reloaded-external ]]        && git clone https://github.com/SonofUgly/PCSX-Reloaded        PCSX-Reloaded-external
    [[ ! -d "${HOME}"/cic-external-vcs/ppsspp-source-external ]]        && git clone https://github.com/hrydgard/ppsspp                ppsspp-source-external
    [[ ! -d "${HOME}"/cic-external-vcs/desmume-external/ ]]             && git clone https://github.com/TASVideos/desmume/             desmume-external
    [[ ! -d "${HOME}"/cic-external-vcs/zathura-external ]]              && git clone https://git.pwmt.org/pwmt/zathura.git             zathura-external
    [[ ! -d "${HOME}"/cic-external-vcs/zathura-cb-external ]]           && git clone https://git.pwmt.org/pwmt/zathura-cb.git          zathura-cb-external
    [[ ! -d "${HOME}"/cic-external-vcs/zathura-djvu-external ]]         && git clone https://git.pwmt.org/pwmt/zathura-djvu.git        zathura-djvu-external
    [[ ! -d "${HOME}"/cic-external-vcs/zathura-pdf-poppler-external ]]  && git clone https://git.pwmt.org/pwmt/zathura-pdf-poppler.git zathura-pdf-poppler-external
    [[ ! -d "${HOME}"/cic-external-vcs/zathura-ps-external ]]           && git clone https://git.pwmt.org/pwmt/zathura-ps.git          zathura-ps-external
    # now build, copied from build-install-software, and should be synced up
    h2 "pip";
    # TODO: upgrade pip automatically?
    curl https://bootstrap.pypa.io/get-pip.py | sudo python;
    h2 "wayback downloader"
    sudo gem install wayback_machine_downloader
    build-install-software-feh
    # build-install-software-mgba
    # build-install-software-pcsx-reloaded
    # TODO: dummy for now
    # build-install-software-ppsspp
    # TODO: dummy for now
    # build-install-software-desmume
    build-install-software-xpdf
    build-install-software-zathura
    popd >/dev/null
}

build-install-software-zathura () {
    # TODO: use some better versions than these giant hashes....
    #       have checks to make sure branches don't hang around
    h2 "girara";
    [[ ! -d "girara-external" ]] && yell "Directory girara-external not found!" && return 1
    sudo true || return 1
    pushd . > /dev/null;
    cd girara-external;
    check-host-main && git pull
    # TODO: this needs to be checked, check if branch develop already exists
    git checkout --track -b develop origin/develop
    # TODO: temporary until I upgrade debian
    # 0.2.7 release, last version my zathura will work with
    # git checkout fe7e9194e2005a263e77c132afb3b3ef13b2aefe
    # make clean;
    # make;
    # sudo make install;
    meson build
    cd build
    ninja
    sudo ninja install
    cd ..
    # TODO: back to develop
    git checkout develop
    popd > /dev/null;
    h2 "zathura";
    [[ ! -d "zathura-external" ]] && yell "Directory zathura-external not found!" && return 1
    pushd . > /dev/null;
    cd zathura-external;
    check-host-main && git pull
    git checkout --track -b develop origin/develop
    # TODO: temporary until I upgrade debian
    #       last version supporting girara 0.2.7
    # git checkout cd8931cb14a89a3558d6bbbc3f9bfbe972d713dd
    # make clean;
    # make;
    # sudo make install;
    meson build
    cd build
    ninja
    sudo ninja install
    cd ..
    git checkout develop
    popd > /dev/null;
    h2 "zathura-poppler";
    # XXXX: a nasty hack
    # TODO: do I still need this
    # sudo cp /usr/lib/pkgconfig/girara-gtk3.pc /usr/lib/pkgconfig/girara-gtk.pc
    pushd . > /dev/null;
    [[ ! -d "zathura-pdf-poppler-external" ]] && yell "Directory zathura-pdf-poppler-external not found!" && return 1
    cd zathura-pdf-poppler-external;
    check-host-main && git pull
    git checkout --track -b develop origin/develop
    # TODO: temporary until I upgrade debian
    # git checkout ced9b3cfb0d7440a6a049f200a2f419ce09abe1e
    # make clean;
    # make;
    # sudo make install;
    meson build
    cd build
    ninja
    sudo ninja install
    cd ..
    git checkout develop
    popd > /dev/null;
    h2 "zathura-djvu";
    [[ ! -d "zathura-djvu-external" ]] && yell "Directory zathura-djvu-external not found!" && return 1
    pushd . > /dev/null;
    cd zathura-djvu-external;
    check-host-main && git pull
    git checkout --track -b develop origin/develop
    # TODO: temporary until I upgrade debian
    # git checkout e4a9ec93e2a4ff68255a38ff327179241fb69ebe
    # make clean;
    # make;
    # sudo make install;
    meson build
    cd build
    ninja
    sudo ninja install
    cd ..
    git checkout develop
    popd > /dev/null;
    h2 "zathura-cb";
    [[ ! -d "zathura-cb-external" ]] && yell "Directory zathura-cb-external not found!" && return 1
    pushd . > /dev/null;
    cd zathura-cb-external;
    check-host-main && git pull
    git checkout --track -b develop origin/develop
    # TODO: temporary until I upgrade debian
    # git checkout 21fa0f4d8da39ed9be449400d2147b876b739f56
    meson build
    cd build
    ninja
    sudo ninja install
    cd ..
    # make clean;
    # make;
    # sudo make install;
    git checkout develop
    popd >/dev/null
    h2 "zathura-ps";
    [[ ! -d "zathura-ps-external" ]] && yell "Directory zathura-ps-external not found!" && return 1
    pushd . > /dev/null;
    cd zathura-ps-external;
    check-host-main && git pull
    git checkout --track -b develop origin/develop
    # TODO: temporary until I upgrade debian
    # git checkout 91a22c4d44eabfca37f0c4488c4b2d18cab3ddb
    meson build
    cd build
    ninja
    sudo ninja install
    cd ..
    git checkout develop
    popd >/dev/null
}

build-install-software-xpdf () {
    # do xpdf, but not on all machines
    if check-host-main || check-host-laptop;then
        h2 "xpdf"
        [[ ! -d "xpdf-3.04-external" ]] && yell "Directory xpdf-3.04-external not found!" && return 1
        sudo true || return 1
        pushd . >/dev/null
        cd xpdf-3.04-external
        # these work on debian 8.x
        make clean
        ./configure --with-freetype2-library=/usr/lib/x86_64-linux-gnu \
                    --with-freetype2-includes=/usr/include/freetype2 \
                    --with-Xm-library=/usr/lib \
                    --with-Xm-includes=/usr/include/Xm
        make
        sudo make install
        popd >/dev/null
    fi
}

build-install-software-mupdf () {
    h2 "mupdf"
    [[ ! -d "mupdf-external" ]] && yell "Directory mupdf-external not found!" && return 1
    sudo true || return 1
    pushd . >/dev/null
    cd mupdf-external
    git submodule update --init
    make prefix=/usr/local
    sudo make prefix=/usr/local install
    popd >/dev/null
}

# TODO: will do with more, but for now I build feh on its own a lot
build-install-software-feh () {
    h2 "feh"
    [[ ! -d "feh-external" ]] && yell "Directory feh-external not found!" && return 1
    sudo true || return 1
    # must be in proper directory
    pushd . >/dev/null
    cd feh-external
    check-host-main && git pull
    make clean
    make exif=1 help=1 xinerama=0
    sudo make install
    popd >/dev/null
}

build-install-software-mgba () {
    h2 "mgba"
    [[ ! -d "mgba-external" ]] && yell "Directory mgba-external not found!" && return 1
    sudo true || return 1
    pushd . > /dev/null;
    cd mgba-external
    check-host-main && git pull
    mkdir -p build
    cd build
    make clean
    cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr/local ..
    make
    sudo make install
    popd >/dev/null
}

build-install-software-pcsx-reloaded () {
    # PCSX-Reloaded
    # TODO: check out as well
    h2 "PCSX-Reloaded"
    [[ ! -d "PCSX-Reloaded-external" ]] && yell "Directory PCSX-Reloaded-external not found!" && return 1
    sudo true || return 1
    pushd . > /dev/null;
    cd PCSX-Reloaded-external
    check-host-main && git pull
    make clean
    bash ./autogen.sh
    # TODO: broken on my machines
    # ./configure --enable-opengl
    ./configure
    make
    sudo make install
    popd >/dev/null
}

build-install-software-ppsspp () {
    h2 "ppsspp (empty)"
    [[ ! -d "ppsspp-source-external" ]] && yell "Directory ppsspp-source-external not found!" && return 1
    sudo true || return 1
    pushd . > /dev/null;
    cd ppsspp-source-external
    check-host-main && git pull
    popd >/dev/null
}

build-install-software-desmume () {
    h2 "desmume"
    [[ ! -d "desmume-external" ]] && yell "Directory desmume-external not found!" && return 1
    sudo true || return 1
    pushd . >/dev/null;
    cd desmume-external
    check-host-main && git pull
    cd src/frontend/posix
    ./autogen.sh
    ./configure
    make
    popd >/dev/null
}

build-install-software-mgba () {
    h2 "mgba"
    [[ ! -d "mgba-external" ]] && yell "Directory mgba-external not found!" && return 1
    sudo true || return 1
    pushd . > /dev/null;
    cd mgba-external
    check-host-main && git pull
    # TODO: rm -rf build
    mkdir build
    cd build
    cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr/local ..
    make
    sudo make install
    popd >/dev/null
}

build-install-software-zsnes () {
    # TODO: broken
    h2 "zsnes"
    [[ ! -d "zsnes-external" ]] && yell "Directory zsnes-external not found!" && return 1
    sudo true || return 1
    pushd . > /dev/null;
    cd zsnes-external
    check-host-main && git pull
    cd src
    ./configure
    make
    sudo make -install
    popd >/dev/null
}

build-install-software-dockapps () {
    cd "$HOME"/cic-external-vcs/
    # need proper version of dockapps and wmgeneral built
    # https://unix.stackexchange.com/questions/67781/use-shared-libraries-in-usr-local-lib
    h2 "libdockapps"
    [[ ! -d "dockapps-external" ]] && yell "Directory dockapps-external not found!" && return 1
    sudo true || return 1
    pushd . >/dev/null
    cd dockapps-external
    check-host-main && git pull
    cd libdockapp
    make clean
    ./configure
    make
    sudo make install
    popd >/dev/null
    sudo ldconfig
    h2 "pywmdockapps"
    pushd . >/dev/null
    cd pywmdockapps-external/pywmdockapps-1.21
    [[ -d ./build ]] && rm -rf ./build
    sudo python ./setup.py install
    popd >/dev/null
    h2 "wmtimer"
    pushd . >/dev/null
    cd wmtimer-external
    check-host-main && git pull
    cd wmtimer
    make clean
    make
    sudo make install
    # TODO: a fix somehow needed
    sudo chmod 755 /usr/local/bin/wmtimer
    popd >/dev/null
    h2 "wmsun"
    pushd . >/dev/null
    cd dockapps-external/wmsun
    make clean
    LDFLAGS="-L/usr/local/lib" make
    sudo make install
    popd >/dev/null
    h2 "wmweather"
    pushd . >/dev/null
    cd wmweather-external/wmweather-2.4.6/src
    make clean
    ./configure
    make
    sudo make install
    popd >/dev/null
    h2 "wmweatherplus"
    pushd . >/dev/null
    cd wmweatherplus-external
    make clean
    ./configure
    make
    sudo make install
    popd >/dev/null
    h2 "wmcalc"
    pushd . >/dev/null
    cd dockapps-external/wmcalc
    make clean
    make
    sudo make install
    popd >/dev/null
    h2 "wmgtemp"
    pushd . >/dev/null
    cd dockapps-external/wmgtemp
    autoreconf -i
    make clean
    ./configure
    make
    sudo make install
    popd >/dev/null
    h2 "wmcpufreq"
    pushd . >/dev/null
    cd dockapps-external/wmcpufreq/wmcpufreq
    make clean
    SYSTEM="-L/usr/local/lib" make
    sudo make install
    popd >/dev/null
}

ag-list-explicitly-installed () {
    aptitude search '~i !~M'
}

amixer-volumes () {
    echo $(amixer get Master | grep Front.*Playback | tr "\\n" " " | sed -e 's/Front//g' -e 's/Playback//g' -e 's/\s[0-9]\+//g' -e 's/  */ /g')
}

notify-amixer-mute () {
    if amixer get Master | grep "\[on\]"; then
        notify-send "Unmuted" -t 200
    else
        notify-send "Muted" -t 200
    fi
}

notify-amixer-volumes () {
    notify-send "$(amixer-volumes)" -t 200
}

show-all-x-displays () {
    # https://unix.stackexchange.com/questions/17255/is-there-a-command-to-list-all-open-displays-on-a-machine
    cd /tmp/.X11-unix && for x in X*; do echo ":${x#X}"; done
}

phoronix-describe-all-tests () {
    (IFS=$'\n'
     for testline in $(\phoronix-test-suite list-available-tests | tail -n +5 | head -n -2); do
         h2 $(echo "$testline" | awk '{ print $1 }')
         \phoronix-test-suite info $(echo "$testline" | awk '{ print $1 }')
     done)
}

inhibit-powersave () {
    # make sure screensaver does not restart
    # TODO: inhibit power management too
    # TODO: if I can blow out of loop and reenable screensaver?
    # TODO: power up all...
    while true; do
        echo "Trying..."
        xscreensaver-command -exit
        # https://bbs.archlinux.org/viewtopic.php?id=134289
        xset -dpms
        xset dpms 0 0 0
        cpu-throttle-up
        sleep 15
    done
}

grep-functions () {
    declare -F | grep -- "$1"
}

rsync-remove-source () {
    # TODO: better interace
    # TODO: still put right picket fence
    # if [[ ! -d "$1" ]]; then
    #     yell "Empty arguments!"
    #     return 1
    # fi
    if ssh "${1}" true; then
        msg "Incoming from ${1}"
        local BACKUPDIR="rsync-backups-${1}-$(date-time-stamp)"
        rsync --progress --archive --checksum --backup --backup-dir="$BACKUPDIR" --rsh='ssh' --remove-source-files ${1}:"$2"/ .
        # will cause error if there are backups
        rmdir --ignore-fail-on-non-empty "$BACKUPDIR"
    else
        warn "Hostname $1 not found!"
    fi
}

rsync-check-source () {
    # do this before running above with same arguments
    if ssh "${1}" true; then
        # TODO: make explicitly that contents of that directory come into current directory
        rsync --verbose --checksum --progress --archive  --rsh='ssh' ${1}:"$2"/ .
    else
        warn "Hostname $1 not found!"
    fi
}

vcs-incoming () {
    # https://stackoverflow.com/questions/1331385/how-can-i-see-incoming-commits-in-git
    # do not do above anymore
    # https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch
    h2 "The log: "
    # TODO: configure a little better, want to see on screen and not wierd pager stuff
    git log --decorate=full --graph --stat ..origin/"$(git rev-parse --abbrev-ref HEAD)"
    read -n 1 -s -r -p "Press any key to continue... "
    echo ""
    h2 "The diffs: "
    git diff --stat @{upstream}
    git diff @{upstream}
}

vcs-reset () {
    # dangerous command, check first
    # TODO: often used to reset and pull
    if dangerous-function-ask; then
        git reset --hard HEAD
    fi
}

trim-mp3-to-30min () {
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 00:30:00 "$2"
}

normalize-volume () {
    # set system volume to nice levels on one run
    amixer set Master 50%
    amixer set Master unmute
    # youtube volume sometimes stupid, normalize it too
    youtube-normalize-volume
    local DATESTAMP=$(date-time-stamp)
    notify-send "Normalizing volume" "$DATESTAMP" -t 5000
}

youtube-normalize-volume () {
    # global function to normalize volume in youtube windows
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if xdotool search --class conkeror | grep -- "${line}" >/dev/null; then
            xdotool windowfocus --sync "${line}";
            xdotool windowactivate --sync "${line}"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.05
            conkeror-batch -f youtube-normalize-volume
        fi
    done
    # TODO: very arbitrary, perhaps wait for something to return
    sleep 0.05
    xdotool windowactivate --sync ${CURRENTWINDOW}
}

alias ffn='find-iname'
find-iname () {
    # TODO: need alias for this
    find . -iname '*'"$1"'*'
}

xset-query () {
    xset q
}

grep-gz-files () {
    # only elisp for now
    find -name "*.el.gz" -print0 | xargs -0 zgrep "$1"
}

strip-leading-trailing-chars () {
    # strip leading and trail characters I do not want for many applications
    # TODO: keep adding more as I need them
    # TODO: make work with more things
    read string
    echo "$string" | sed 's/^[-]*//' | sed 's/[-]*$//'
}

gpg-batch () {
    gpg2 --no-verbose --quiet --batch --yes "$@"
}


android-screenshot-all () {
    pushd . >/dev/null
    cd "${HOME}"
    # TODO: better name...
    local FNAME=android-screen-$(date-time-stamp).png
    adb shell screencap -p /sdcard/"$FNAME"
    adb pull /sdcard/"$FNAME"
    adb shell rm /sdcard/"$FNAME"
    popd >/dev/null
}

android-record-all () {
    # TODO: specify time limit better
    pushd . >/dev/null
    cd "${HOME}"
    local FNAME=android-screenrecord-$(date-time-stamp).mp4
    adb shell screenrecord --verbose --time-limit 180 /sdcard/"$FNAME"
    adb pull /sdcard/"$FNAME"
    adb shell rm /sdcard/"$FNAME"
    popd >/dev/null
}

harm-fonts () {
    sudo dpkg-reconfigure fontconfig
    # TODO: sudo? not yet, make sure this is necessary?
    # fc-cache -f -v
}

benchmark-compression-gzip () {
    # benchmark gzip compression
    du -sh "$1"
    time {
        tar --create --file - "$1" | gzip -9 > test.tgz
    }
    echo ""
    du -sh "test.tgz"
    time {
        # XXXX: hope this is not optimized!
        gzip -d test.tgz >/dev/null
    }
    sleep 10
    rm test.tar
}

benchmark-compression-bzip2 () {
    # benchmark bzip2 compression
    du -sh "$1"
    time {
        tar --create --file - "$1" | bzip2 -9 > test.tar.bz2
    }
    echo ""
    du -sh "test.tar.bz2"
    time {
        # XXXX: hope this is not optimized!
        bzip2 -d test.tar.bz2 >/dev/null
    }
    sleep 10
    rm test.tar
}

benchmark-compression-lz4 () {
    # benchmark lz4 compression
    du -sh "$1"
    time {
        tar --create --file - "$1" | lz4 -9 > test.tar.lz4
    }
    echo ""
    du -sh test.tar.lz4
    time {
        # XXXX: hope this is not optimized!
        lz4 -d test.tar.lz4 test.tar &>/dev/null
    }
    sleep 10
    rm test.tar
    rm test.tar.lz4
}

benchmark-compression-lzop () {
    # benchmark lzop compression
    du -sh "$1"
    time {
        tar --create --file - "$1" | lzop -9 > test.tar.lzop
    }
    echo ""
    du -sh test.tar.lzop
    time {
        # XXXX: hope this is not optimized!
        lzop -d test.tar.lzop >/dev/null
    }
    sleep 10
    rm test.tar.lzop
    rm test.tar
}

benchmark-compression-rzip () {
    # benchmark rzip compression
    du -sh "$1"
    time {
        tar --create --file - "$1" > test.tar;rzip -9 test.tar -o test.tar.rz
    }
    echo ""
    du -sh test.tar.rz
    time {
        rzip -d test.tar.rz
    }
    sleep 10
    rm test.tar
}

benchmark-compression-lzip () {
    # benchmark lzip compression
    du -sh "$1"
    time {
        tar --create --file - "$1" | lzip -9 > test.tar.lzip
    }
    echo ""
    du -sh test.tar.lzip
    time {
        # XXXX: hope this is not optimized!
        lzip -d -c test.tar.lzip > test.tar
    }
    sleep 10
    rm test.tar.lzip
    rm test.tar
}

benchmark-compression-xz () {
    # benchmark lz compression
    du -sh "$1"
    time {
        tar --create --file - "$1" | xz -9 > test.tar.xz
    }
    echo ""
    du -sh test.tar.xz
    time {
        # XXXX: hope this is not optimized!
        xz -d test.tar.xz >/dev/null
    }
    sleep 10
    rm test.tar
}

benchmark-compression-all () {
    # benchmark all supported compression methods
    h2 "gzip"
    benchmark-compression-gzip "$1"
    h2 "bzip2"
    benchmark-compression-bzip2 "$1"
    h2 "lz4"
    benchmark-compression-lz4 "$1"
    h2 "lzop"
    benchmark-compression-lzop "$1"
    h2 "rzip"
    benchmark-compression-rzip "$1"
    h2 "lzip"
    benchmark-compression-lzip "$1"
    h2 "xz"
    benchmark-compression-xz "$1"
}

pdftk-cat () {
    if [[ -z "$1" ]]; then
        echo "pdftk-cat <<pdf basename to create>>"
    else
        # create pdf from alphabetically-order pdfs in current directory, using pdftk
        pdftk *.pdf cat output "$1".pdf
    fi
}

pdftk-split () {
    if [[ -z "$1" ]]; then
        echo "pdftk-split <<pdf filename in>> <<start page>> <<end page>>" "<<pdf filename out>>"
        echo "Use page numbering and not page naming."
    else
        # create pdf from alphabetically-order pdfs in current directory, using pdftk
        pdftk "$1" cat "$2"-"$3" output "$4"
    fi
}

alias cdf="cd-first"
cd-first () {
    # go to the first matching pattern
    local FIRST=$(ls --color=never -dtr1 "$1"* | head -1)
    cd "$FIRST"
}
alias lsf="ls-first"
ls-first () {
    # go to the first matching pattern
    local FIRST=$(ls --color=never -dtr1 "$1"* | head -1)
    ls "$FIRST"
}

alias cdl="cd-latest"
cd-latest () {
    # go to the lastest matching pattern
    local LATEST=$(ls --color=never -dtr1 "$1"* | tail -1)
    cd "$LATEST"
}
alias lsl="ls-latest"
ls-latest () {
    # go to the lastest matching pattern
    local LATEST=$(ls --color=never -dtr1 "$1"* | tail -1)
    ls "$LATEST"
}

list-x11-displays () {
    pushd . >/dev/null
    cd /tmp/.X11-unix
    for x in X*; do
        echo ":${x#X}";
    done
    popd >/dev/null
}

screen-list-all-session-commands () {
    # based on
    SCREEN_SESSIONS=( $(screen -ls | grep pts | cut -f1 -d"." | sed -e 's/^[[:space:]]*//g') )
    for SCREEN_SESSION_PID in "${SCREEN_SESSIONS[@]}";do
        h2 "Screen session pid: $SCREEN_SESSION_PID"
        screen -ls "$SCREEN_SESSION_PID"
        # TODO: will all screens have bash base
        SCREEN_CHILD=$(ps -el | grep -- $(ps -el | grep "$SCREEN_SESSION_PID" | grep bash | awk '{print $4}') | grep -v bash | awk '{print $4}')
        if [[ -n "$SCREEN_CHILD" ]]; then
            echo $(ps u -p "$SCREEN_CHILD") | fold -w 160
        else
            warn "No non-bash child process!"
        fi
    done
}
# TODO: do I want scl to always do this?
alias scl-commands="screen-list-all-session-commands"

ag-sizes () {
    # get sorted sizes of packages installed
    dpkg-query -Wf '${Installed-Size}\t${Package}\n' | sort --numeric -
}

# TODO: this is temporary, means I am forced to use sc, eventually want screen to just do this
screen-default () {
    if [[ -z "$1" || ! "$1" =~ ^- ]]; then
        yell "Default screen must have options associated with it! Use sc command to start screen instead!"
        return 1
    fi
    \screen "$@"
}
alias screen='screen-default'

screen-name () {
    if [[ -z "$1" ]]; then
        yell "Must specify screen session name!!!"
        return 1
    fi
    local SCREEN_SESSION="$1"
    shift
    screen -S "$SCREEN_SESSION" "$@"
}
alias sc='screen-name'

find-newest-modified () {
    # find . -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head
    find . -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head -n 20
}

tar-to-here () {
    tar cvzf ./"$2".tgz "$1"
}

# https://stackoverflow.com/questions/26621647/convert-human-readable-to-bytes-in-bash
dehumanise() {
  for v in "$@"; do
    echo $v | awk \
      'BEGIN{IGNORECASE = 1}
       function printpower(n,b,p) {printf "%u\n", n*b^p; next}
       /[0-9]$/{print $1;next};
       /K(iB)?$/{printpower($1,  2, 10)};
       /M(iB)?$/{printpower($1,  2, 20)};
       /G(iB)?$/{printpower($1,  2, 30)};
       /T(iB)?$/{printpower($1,  2, 40)};
       /KB$/{    printpower($1, 10,  3)};
       /MB$/{    printpower($1, 10,  6)};
       /GB$/{    printpower($1, 10,  9)};
       /TB$/{    printpower($1, 10, 12)}'
  done
}

vcs-change-remote () {
    # no arguments just gives remotes
    if [[ -z "$1" ]];then
        git remote -v
    else
        git remote set-url "$1" "$2"
    fi
}

WGETOKCODES="200 OK\|302 Found"
WGETERRORCODES="301 Moved Permanently\|404 Not Found\|406 Not Acceptable\|503 Service Unavailable\|504 Gateway Time-out\|Read error\|416 Requested Range Not Satisfiable\|300 Multiple Choices\|500 Internal Server Error\|^Error\|^Retrying\|^Giving\|Data connection: Connection timed out"

wget-check-log-unknown-codes () {
    # TODO: find things that are not these, so I can start catologuing good errors
    # TODO: see if I can identify fatal errors
    grep -Hn -- "awaiting response" "$1" | grep -v -- "$WGETOKCODES"  | grep -v -- "$WGETERRORCODES"
    # TODO: more informative return code?
    return 0
}

wget-check-log () {
    # TODO: find things that are not these, so I can start catologuing good errors
    # TODO: can I search in a grep function
    h1 "Error codes"
    grep --color=always -Hn -B 2 -A 4 -- "$WGETERRORCODES" "$1"
    h1 "Unknown codes"
    wget-check-log-unknown-codes "$1"
}

als () {
    # archive ls
    # TODO: add help for command to use
    if [[ "$1" == *.tar* || "$1" == *.tgz ]]; then
        tar-ls "$1"
    elif [[ "$1" == *.zip ]]; then
        unzip -l "$1"
    elif [[ "$1" == *.rar ]]; then
        unrar l "$1"
    fi
}

# TODO: combine with above?
tar-ls () {
    if [[ "$1" == *.tar.gz || "$1" == *.tgz ]]; then
        tar -ztf "$1"
    else
        tar -tf "$1"
    fi
}

ls-grep () {
    # a simple function for simple searches of a directory
    ls --color=always -1 | grep --color=always -i -- "$1"

}
alias grep-ls="ls-grep"

grep-less () {
    grep --color=always -Ri $@ | less -r
}
alias less-grep="grep-less"

sqlite-cat () {
    sqlite3 "$1" .dump | less
}
alias cat-sqlite="sqlite-cat"

unzip-all () {
    for F in ./*.zip; do
        mkdir -p "${F}.d"
        pushd . >/dev/null
        cd "${F}.d"
        unzip ../"${F}"
        popd >/dev/null
    done
}

unzip-in-path () {
    if [[ -n "$1" ]] || [[ -f "$1" ]]; then
        mkdir -p "${1}.d"
        cd "${1}.d"
        unzip ../"${1}"
    else
        yell "Does not exist or is not a file!"
    fi
}


unzip-ls () {
    # TODO: check if zip is not here
    for F in ./*.zip; do
        h2 "${F}"
        unzip -l "${F}"
    done
}


# TODO: are these enough patterns?
grep-ri () {
    grep --color=always -Ri "$@" . | grep -v "\\.git/" | less -R
}

less-highlight () {
    # slight delay....
    if [[ -z "$1" ]]; then
        echo "A filename is required for less-pyg!"
    elif [[ -e "$1" ]]; then
        pygmentize -O style=native -g -f terminal256 "$1" | less --ignore-case --LONG-PROMPT --RAW-CONTROL-CHARS +Gg
    else
        echo "File $1 does does not exist!"
    fi
}
alias lh='less-highlight'

less-sh () {
    # faster... but looks terrible by default
    # TODO: fix colors on this
    /usr/share/source-highlight/src-hilite-lesspipe.sh "$1" | less
}

count-nondot-files () {
    find . -type f -not -path '*/\.*' | wc -l
}

geotiff-info () {
    for F in $@; do
        [[ "$F" =~ "tif" ]] || continue
        h2 "$F"
        gdalinfo "$F"
    done
}

check-git-repo () {
    [[ -d .git ]] || git rev-parse --git-dir &>/dev/null
}

ag-reinstall-all () {
    if dangerous-function-ask; then
        sudo dpkg --get-selections > ${HOME}/list.log
        for i in $(cat list.log); do sudo apt-get install --reinstall "$i"; done
    fi
}

ag-reinstall-dependent () {
    if [[ -n "$1" ]]; then
        if dangerous-function-ask; then
            # https://askubuntu.com/questions/275719/reinstall-package-and-its-installed-dependencies
            sudo apt-cache depends "$1" | grep '[ |]Depends: [^<]' | cut -d: -f2 | tr -d ' ' | xargs sudo apt-get --reinstall install -y
        fi
    fi
}

check-permissions-rw () {
    # find files I do not own
    h3 "Files not owned or in my group"
    find . ! -user "${USER}"
    h3 "Directories I do not have sufficient privileges for"
    # TODO: exclude .git
    find . -type d -user "${USER}" ! -perm -700
    h3 "Files I do not have sufficient privileges for"
    # TODO: exclude .git
    find . -user "${USER}" ! -perm -600
}
