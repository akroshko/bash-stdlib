#!/bin/bash
# bash_functions_stdlib is a set of bash functions for non-specific
# functionality.
#
# Copyright (C) 2015-2019, Andrew Kroshko, all rights reserved.
#
# Author: Andrew Kroshko
# Maintainer: Andrew Kroshko <akroshko.public+devel@gmail.com>
# Created: Fri Mar 27, 2015
# Version: 20180918
# URL: https://github.com/akroshko/bash-stdlib
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

# WARNING: most of this code has not been rigorously tested or
# verified, use at own risk if working with important data or in
# production settings

test-fail () {
    # this function is just a test to judge a scripts behaviour based
    # on return values
    # TODO: also need a test error
    if [[ false ]]; then
        echo "false"
        return 1
    fi
    echo "not false"
    return 0
}

check-host () {
    # check if current host is a particular host, this will probably
    # become more complex as time goes on
    [[ "$HOSTNAME" == "$1" ]]
}

need_new_directory () {
    # create a new directory if it does not already exist
    mkdir -p "$1"
}

verify-operation () {
    # this function verifies a deletion and asks twice to make sure,
    # generally used to ensure an operation is successful before
    # deleting
    local ASKMESSAGE="$1"
    local SUREMESSAGE="$2"
    local RMARG="$3"
    while true; do
        while read -r -t 0;do read -r; done
        read -n 1 -p "$ASKMESSAGE" YN
        echo ""
        case $YN in
            # TODO: make a bit more general so I can select a command
            [Yy]* ) (home-trash "$RMARG"); break;;
            # are you sure you don't want to delete original
            [Nn]* )
                while read -r -t 0;do read -r; done
                read -p "$SUREMESSAGE" YNT
                case $YNT in
                    [Yy]* ) return 0;;
                    [Nn]* ) true;;
                    * ) warn "Try again!"
                esac
                ;;
            * ) warn "Please answer yes or no.";;
        esac
    done
}

home-trash () {
    # delete by moving to a trash file that can be periodically
    # checked
    local TRASHFILE="$1"
    mkdir -p "$HOME/tmp/trash"
    \mv --backup=t -- "$TRASHFILE" "$HOME/tmp/trash"
}

date-time-stamp () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%d%H%M%S)
}

date-time-stamp-t () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%dT%H%M%S)
}

date-time-stamp-lower-t () {
    # return a time-stamp with date in standard format
    echo $(date +%Y%m%dt%H%M%S)
}

date-stamp () {
    echo $(date +%Y%m%d)
}

# move this to function ASAP
memory-log () {
    while true; do { cat /proc/meminfo | sed -n 2p ; date ; } | tr "\n" " " ; echo ""; sleep 30; done >> "$HOME/memory-$(date +%Y%m%d%H%M%S).log"
}

ag-show () {
    # show details of a debian package
    apt-cache show "$1"
}
# XXXX: only different when using bash completion
alias ag-show-installed=ag-show

# TODO: search multiple terms?
ag-search () {
    # search for a debian package
    apt-cache search "$1"
}

ag-install () {
    # TODO: check if already installed
    # TODO: no sudo for dry run??? abort if can't sudo?
    # TODO: check if apt-get update needed
    apt-get install --dry-run "$@"
    echo "Do install for real?"
    # install a debian package
    if ask_yn "Install?";  then
        sudo apt-get install "$@"
    else
        msg "Aborting!"
    fi
}

ag-install-dry-run () {
    apt-get install --dry-run "$@"
}

ag-remove () {
    # uninstall a debian package
    sudo apt-get remove "$@"
}

ag-list () {
    # list files installed by a debian package
    dpkg-query -L "$1"
}

# TODO: search multiple terms?
ag-list-installed () {
    if [[ -z "$1" ]]; then
        dpkg-query -l
    else
        dpkg-query -l | grep -- "$1"
    fi
}

# TODO: see if I can use aes256-gcm@openssh.com for everything

ssh-batch () {
    ssh -o "BatchMode yes" "$@"
}

ssh-batch-lan () {
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" "$@"
}

ssh-batch-interact () {
    # go in in batch mode but allow interaction
    # generally want things to fail when authentication agents not working
    ssh -o "BatchMode yes" -t "$@"
}

ssh-batch-interact-lan () {
    # go in in batch mode but allow interaction
    # generally want things to fail when authentication agents not working
    ssh -o "Compression no" -c aes256-gcm@openssh.com -o "BatchMode yes" -t "$@"
}

ssh-lan () {
    ssh -o "Compression no" "$@"
}

scp-lan () {
    # use scp over a LAN, sets some good options
    scp -o "Compression no" "$@"
}

sftp-lan () {
    # use sftp over a LAN, sets some good options
    sftp -o "Compression no" "$@"
}


alias ssh-x11='sshx'
sshx () {
    ssh -X -o "Compression yes" "$@"
}

sshnox () {
    # use ssh and explicitly disable X forwarding
    ssh -o "ForwardX11 no" "$@"
}

alias ssh-x11-lan='sshx-lan'
sshx-lan () {
    ssh -X -o "Compression no" "$@"
}

autossh-tunnel () {
    # set up a tunnel using autossh
    autossh -M 0 -o "BatchMode yes" -o "Compression yes" -N "$@"
}

autossh-tunnel-lan () {
    # set up a tunnel using autossh, compression off best for lan
    autossh -M 0 -o "BatchMode yes" -o "Compression no" -N "$@"
}

transform-resize-web () {
    # resize photos to a nice size for the web
    # TODO: change the prefix name?
    convert "$1" -resize 1200x800 "resize_$1"
}

# transform anything to mp3 using ffmpeg
transform-ffmpeg-mp3 () {
    # convert any media file to an mp3
    # TODO: ffmpeg not on debian currently (8.3)
    ffmpeg -i "$1" -f mp3 "${1%.*}.mp3"
}

transform-rotate-right () {
    # rotate a photo right 90 degrees
    convert "$1" -rotate 90 "rotate_$1"
}

transform-rotate-180 () {
    # flip a photo 180 degrees
    convert "$1" -rotate 180 "rotate_$1"
}

transform-rotate-left () {
    # rotate a photo left 90 degrees
    convert "$1" -rotate 270 "rotate_$1"
}

serve-here () {
    # serve the current directory here on port 8080
    ifconfig
    python -m SimpleHTTPServer 8080
}

nmap-network () {
    # use nmap to show network interfaces
    nmap --iflist
}

nmap-host-ports () {
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time nmap -v -sT -p 1-65535 "$1"
}

nmap-host-ports-super () {
    if [[ -z "$1" ]]; then
        yell "Requires argument!"
        return 1
    fi
    time nmap -v -sS -p 1-65535 "$1"
}

nmap-lan () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time nmap -sP 192.168.0-1.0-255
}

nmap-lan-os () {
    # scan current network, based on common home router addresses,
    # quickly using nmap
    # XXXX: generally takes less than a minute
    time sudo nmap -sS -O 192.168.0-1.0-255
}

nmap-lan-super () {
    # scan current network, based on common home router addresses,
    # slowly using nmap
    # XXXX: generally takes less than a 10 minutes, or lesss than 10 seconds
    time sudo nmap -sS 192.168.0-1.0-255
}

nmap-lan-complete () {
    # scan current network completely using nmap
    time sudo nmap -sP 192.168.0.0/16
}

nmap-lan-complete-super () {
    # scan current network completely and slowly using nmap
    time sudo nmap -sS 192.168.0.0/16
}

netstat-connections () {
    # check current networking connections
    netstat --udp --tcp --all --numeric --programs
}

netstat-connections-super () {
    # check current networking connections
    sudo netstat -untap
}

lpr-double-sided-portrait () {
    # print file as double-sided in portrait mode
    lpr -o sides=two-sided-long-edge "$1"
}

lpr-double-sided-landscape () {
    # print file as double-sided in landscape mode
    lpr -o sides=two-sided-short-edge "$1"
}

ls-sort-date () {
    # ls and sort by reverse date
    ls -ltr
}

need_new_symlink () {
    # create new symlink deleting old symlinks but not old files
    if [[ -e "$2" && ! -h "$2" ]]; then
        # symlink is a file or something
        yell "$2: exists but is not a symlink!!!"
    elif [[ ! -h "$2" ]]; then
        # symlink does not exist at all or is a file
        ln -s "$1" "$2"
    elif [[ -h "$2" && ! -e "$2" ]]; then
        # symlink exists but is invalid
        rm -f "$2"
        ln -s "$1" "$2"
    elif [[ -h "$2" && $(readlink -f "$2") != $(readlink -f "$1") ]]; then
        # symlink exists but points to different location than we are going to
        yell "Symlink $2 exists but points to $(readlink -f "$2") instead of $1!"
    fi
}

need_new_symlink_touch () {
    touch "$1"
    need_new_symlink "$1" "$2"
}

# TODO: do something if there is a directory
cp_if_different () {
    local FOUNDDIFFERENT=1
    # is destination a directory
    if [[ -d "$2" ]]; then
        local THEBASENAME=$(basename "$1")
        if ! cmp --silent "$1" "$2"/"$THEBASENAME"; then
            command cp "$1" "$2"
            FOUNDDIFFERENT=0
        fi
    else
        if [[ ! -e "$2" ]] || ! cmp --silent "$1" "$2"; then
            command cp "$1" "$2"
            FOUNDDIFFERENT=0
        fi
    fi
    return $FOUNDDIFFERENT
}

match_string_array () {
    # check if a given string is in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 0; done
    return 1
}

not_match_string_array () {
    # check if a given string is not in a given array
    # string in $1, array in $2
    local e
    for e in "${@:2}"; do [[ "$e" =~ "$1" ]] && return 1; done
    return 0
}

view-def () {
    # view the definition of a bash function
    # TODO: what if I have something as both alias and bash function
    # TODO: avoid double run
    if declare -f "$1" 2>&1 >/dev/null; then
        h1 "Bash function definition"
        declare -f "$1"
    fi
    if alias | grep -- '^alias \([A-Za-z0-9_-]*'"$1"'[A-Za-z0-9_-]*\)=' 2>&1 >/dev/null; then
       h1 "Alias definition"
       alias | grep -- '^alias \([A-Za-z0-9_-]*'"$1"'[A-Za-z0-9_-]*\)='
    fi
}

read-file-regexp () {
    # read lines from a file and merge them into a regexp
    local NEWREGEXP=""
    while read line; do
        NEWREGEXP+=$line"|"
    done < "$1"
    echo ${NEWREGEXP::-1}
}

clean-pwd-files-pretend () {
    # see if files in current directory can be renamed to be safe from
    # punctuation and unicode boogeymen
    rename -n "s|'||g" *
    rename -n "s|:||g" *
    rename -n "s|\xe2\x80\x99||g" *
    rename -n "s|\xe2\x80\x93|-|g" *
    rename -n "s|\xe2\x80\x94|-|g" *
    rename -n "s|\xc2\xa1|-|g" *
}

clean-pwd-files () {
    # actually rename files in current directory to be safe from
    # punctuation and unicode boogeymen
    rename "s|'||g" *
    rename "s|:||g" *
    rename "s|\xe2\x80\x99||g" *
    rename "s|\xe2\x80\x93|-|g" *
    rename "s|\xe2\x80\x94|-|g" *
    rename "s|\xc2\xa1|i|g" *
}

psg () {
    if [[ -z "$1" ]]; then
        ps -efj | less
    else
        # TODO: this can be done better!
        ps -efj | head -n 1
        ps -efj | grep -- "$1"
    fi
}

cpu-throttle-up () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "$i" -g performance
    done
}

cpu-throttle-ondemand () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "$i" -g ondemand
    done
}

cpu-throttle-down () {
    for (( i = 0; i < $(nproc); i++ )); do
        sudo cpufreq-set -c "$i" -g powersave
    done
}

find-broken-symlinks () {
    # find- for useful find command variations
    find . -type l -xtype l
}

xclip-show-all () {
    # TODO: maybe only show extra line if necessary
    h1
    msg "Primary"
    xclip -o -selection p
    echo ""
    h1
    msg "Secondary"
    xclip -o -selection s
    echo ""
    h1
    msg "Clipboard"
    xclip -o -selection c
    echo ""
}

# TODO: pop this up somehow with a key
watch-xclip-show-all () {
    watch -n 1 --color --exec bash -c "source $HOME/.bash_library;xclip-show-all"
}

# watch-xclip () {
#     while true; do
#         # calling xclip-show-all does not do as expected
#         h1
#         msg "Primary"
#         xclip -o -selection p
#         h1
#         msg "Secondary"
#         xclip -o -selection s
#         h1
#         msg "Clipboard"
#         xclip -o -selection c
#         sleep 1
#     done
# }

du-sort () {
    # sort by size after using du
    \du --total --summarize --human-readable -- * 2>/dev/null | sort --human-numeric-sort
}

du-sort-symlinks () {
    # sort by size after using du
    \du --total --summarize --human-readable --dereference -- * 2>/dev/null | sort --human-numeric-sort
}


du-sort-directories () {
    # sort by size after using du
    # TODO: single file system?
    \du --total --summarize --human-readable -- ./*/ 2>/dev/null | sort --human-numeric-sort
}

du-sort-dotfiles () {
    du --summarize --human-readable .[^.]* 2>/dev/null | sort --human-numeric-sort
}

du-total-symlink () {
    # sort by size after using du
    du --summarize --total --dereference --human-readable * 2>/dev/null
}

dd-progress () {
    # TODO: spaces after | ???
    #       try on next big dd
    # ps auxww | grep " [d]d " | awk '{print $2}' |while read pid; do kill -USR1 $pid; done
    # http://askubuntu.com/questions/215505/how-do-you-monitor-the-progress-of-dd
    sudo kill -USR1 $(pgrep ^dd)
}

youtube-mp3 () {
    # download mp3 from youtube
    youtube-dl --extract-audio -audio-format mp3 "$1"
}

dconf-grep () {
    # grep the GNOME config database
    dconf dump / | grep -i -- "$1"
}

dconf-less () {
    # use less to view the GNOME config database
    dconf dump / | less
}

fdi () {
    # search for file matching first argument in tree
    find . -iname "*${1}*"
}

fgi () {
    if [[ -z "$2" ]]; then
        find . -type f -exec grep -H --color -n -- "$1" {}  \;
    else
        find . -type f -iname "*$1*" -exec grep -H --color -n -- "$2" {}  \;
    fi
}

harm-bash () {
    fix-gpg-ssh-permissions
    source "$HOME/.bash_profile"
}

harm-bashrc () {
    fix-gpg-ssh-permissions
    source "$HOME/.bashrc"
}

harm-xresources () {
    # reload x-resources for development purposes
    # otherwise it is done in bash-profile....
    if [[ -f "$HOME/.Xresources" ]]; then
        msg "Loading Xresources!!!"
        xrdb "$HOME/.Xresources"
    fi
}

fix-standard-permissions () {
    true
}

fix-crypt-permissions () {
    # fix the permissions on a cryptography-relevant directory
    if [[ -z "$1" ]]; then
        yell "Must have a file or directory to fix!"
    else
        # fail silently if does not exist
        if [[ -e "$1" ]]; then
            if [[ -d "$1" ]]; then
                chmod --recursive g-rwx "$1"
                chmod --recursive o-rwx "$1"
                chmod u+rwX --recursive "$1"
            else
                chmod g-rwx "$(readlink -f $1)"
                chmod o-rwx "$(readlink -f $1)"
                chmod u+rwX "$(readlink -f $1)"
            fi
        fi
    fi
}

fix-gpg-ssh-permissions () {
    # TODO: start adding things that might be necessary
    # TODO: start adding this to the front of critical operations
    # fix the permissions on the standard gpg and ssh directory
    fix-crypt-permissions "$HOME/.gnupg"
    fix-crypt-permissions "$HOME/.ssh"
    fix-crypt-permissions "$HOME/.msmtprc"
}

backlight-percentage () {
    # XXXX: very device dependent but useful to include, make more general
    echo "`cat /sys/class/backlight/intel_backlight/brightness`*100/`cat /sys/class/backlight/intel_backlight/max_brightness`" | bc -l | xargs printf "%1.0f\n"
}

vcs-check-root () {
    # check if a pull is needed for for child directories if they correspond to common version control systems
    # from https://stackoverflow.com/questions/3258243/git-check-if-pull-needed
    # stop it from running home because that's dumb
    # TODO: other directories
    if [[ "$PWD" == "$HOME" ]]; then
        yell "Cannot run in home directory!!!"
        return 1
    fi
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        # check for various things
        if [[ -d "$dirname/.git" ]]; then
            # TODO: exclude lines saying [up to date] and just give a summary of branches
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            # TODO: why was first git fetch here?
            #       does it stil work the same now?
            # git fetch
            git -c color.ui=always fetch --verbose
            # h2 "diff origin/master"
            # git diff origin/master --summary
            h2 "pull needed?"
            # TODO: indicate no pull needed
            local STATUS=$(git -c color.ui=always status -uno)
            if grep "up-to-date" <<< "$STATUS" >/dev/null; then
                msg "Seems up to date!"
            else
                yell "Not up to date!"
            fi
            echo "$STATUS"
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Checking $dirname/.hg"
            # TODO: non-functional? I have no remaining hg repos
            # pushd . >/dev/null
            # cd "$dirname"
            # hg fetch --dry-run --verbose
            # popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Checking $dirname/.svn"
            pushd . >/dev/null
            cd "$dirname"
            svn status --show-updates
            popd >/dev/null
        else
            h1 "Not checking $dirname"
        fi
    done
}

vcs-check-root-fetch-all () {
    if [[ "$PWD" == "$HOME" ]]; then
        yell "Cannot run in home directory!!!"
        return 1
    fi
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        if [[ -d "$dirname/.git" ]]; then
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            git fetch
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Pulling $dirname/.hg"
            pushd . >/dev/null
            cd "$dirname"
            # hg pull == git fetch
            hg pull
            popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Updating $dirname/.svn"
            yell "Not fetching svn!"
            # pushd . >/dev/null
            # cd "$dirname"
            # svn update
            # popd >/dev/null
        else
            h1 "Not pulling $dirname"
        fi
    done
}

vcs-check-root-pull-all () {
    if [[ "$PWD" == "$HOME" ]]; then
        yell "Cannot run in home directory!!!"
        return 1
    fi
    for dirname in ${PWD}/*; do
        [[ -d "$dirname" ]] || continue
        if [[ -d "$dirname/.git" ]]; then
            h1 "Checking $dirname/.git"
            pushd . >/dev/null
            cd "$dirname"
            git pull
            popd >/dev/null
        elif [[ -d "$dirname/.hg" ]]; then
            h1 "Pulling $dirname/.hg"
            pushd . >/dev/null
            cd "$dirname"
            hg pull
            popd >/dev/null
        elif [[ -d "$dirname/.svn" ]]; then
            h1 "Updating $dirname/.svn"
            pushd . >/dev/null
            cd "$dirname"
            svn update
            popd >/dev/null
        else
            h1 "Not pulling $dirname"
        fi
    done
}

vcs-pi-pull () {
    if [[ "$HOSTNAME" == *pi ]]; then
        cd "$HOME/cic-vcs"
        vcs-check-root-pull-all
        # cd "$HOME/cic-vcs-academic"
        # vcs-check-root-pull-all
    else
        yell "Can only run on raspberry pi hosts!"
    fi
}

vcs-update-versions () {
    # TODO: add fences and safeguards
    # TODO: search recursively with find command
    # find . -not -path "*git*" -type f -exec bash -c 'source ~/.bash_library;vcs-update-file-version "{}"'  \;
    local CURRENTYEAR=$(date +"%Y")
    for f in ${PWD}/*; do
        [[ -f "$f" ]] || continue
        local FILETYPE=$(file -L "$f")
        # if file starts with #!
        if [[ "$(head -n 1 $f)" =~ ^\#! ]]; then
            # hash comment
            sed -i -e "s/^# Version:.*$/# Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if grep -- "^# Copyright" $f >/dev/null && ! grep -- "^# Copyright.*#$CURRENTYEAR" $f >/dev/null; then
                warn "Need to update year in $f"
            fi
        elif [[ "$FILETYPE" =~ "Lisp/Scheme program" || "$VERSIONFILE" =~ \.el$ ]]; then
            # lisp
            sed -i -e "s/^;; Version:.*$/;; Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if grep -- "^;; Copyright" $f >/dev/null && ! grep -- "Copyright.*$CURRENTYEAR" $f >/dev/null; then
                warn "Need to update year in $f"
            fi
        elif [[ "$FILETYPE" =~ "LaTeX document" ]]; then
            # latex
            sed -i -e "s/^% Version:.*$/% Version: $(date-stamp)/g" "$f"
            # if not copyright matches this year
            if ! grep -- "Copyright.*2018" $f >/dev/null; then
                warn "Need to update year in $f"
            fi
        fi
    done
}

fail2ban-check () {
    # check fail2ban status and show number of banned IPs for each date in the past
    sudo zcat /var/log/auth.log*.gz | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    # a hack to find non-gz logs
    sudo cat /var/log/auth.lo*[^z] | grep 'Failed password' | grep sshd | awk '{print $1,$2}' | sort -k 1,1M -k 2n | uniq -c
    sudo fail2ban-client status ssh
    sudo fail2ban-client status ssh-root
}

drop-caches () {
    su -c "free && sync && echo 3 > /proc/sys/vm/drop_caches && free"
}

mount-disk-uuid () {
    # find mounted disk or ???
    local UUID="$1"
    # allow full UUID path to be given
    if [[ "$UUID" == /dev/disk/by-uuid/* ]]; then
        local UUIDDEVICE=$(readlink -f "$UUID")
    else
        local UUIDDEVICE=$(readlink -f "/dev/disk/by-uuid/$UUID")
    fi
    # TODO: do this better
    if findmnt -nr -o target -S "$UUIDDEVICE" >/dev/null; then
        findmnt -nr -o target -S "$UUIDDEVICE"
        return 0
    else
        # TODO: for now I have gnome mount for me but would like to change this
        yell "Disk not mounted!!!"
        return 1
        # # TODO: mount on a temporary directory
        # MOUNTPOINT=$(mktemp -d)
        # sudo mount "$IDDEVICE" "$MOUNTPOINT"
        # echo "$MOUNTPOINT"
    fi
}

device-disk-uuid () {
    # find mounted disk or ???
    local UUID="$1"
    local UUIDDEVICE=$(readlink -f "/dev/disk/by-uuid/$UUID")
    echo "$UUIDDEVICE"
}

get-mount-point-check-usb () {
    if [[ -e "/dev/disk/by-uuid/$1" ]]; then
        # argument is a uuid
        local THEDEVICE="/dev/disk/by-uuid/$1"
        local THEMOUNTPOINT=$(findmnt -nr -o target -S "$THEDEVICE")
    elif [[ "$1" == /dev/* ]];then
        # argument is a device
        local THEDEVICE="$1"
        local THEMOUNTPOINT=$(findmnt -nr -o target -S "$THEDEVICE")
    elif mountpoint -q "$1"; then
         # argument already a mount point
         # TODO: use r
         local THEDEVICE=$(findmnt -nr -o source --target "$1")
         local THEMOUNTPOINT="$1"
    else
        # invalid argument
        return 1
    fi
    local LSBLK=$(\lsblk --list --output +tran)
    local LSBLKUSB=$(\lsblk --list --output +tran | grep usb)
    local USBFOUND=
    while read -r USBLINE; do
        local USBDEV=$(awk '{ print $1 }' <<< "$USBLINE")
        # TODO: better string comparison
        if [[ -n "$USBDEV" ]] && grep --color=never "$USBDEV" <<< "$THEDEVICE" >/dev/null;then
            local USBFOUND=1
        fi
    done <<< "$LSBLKUSB"
    if [[ "$USBFOUND" == 1 ]];then
        echo "$THEMOUNTPOINT"
    else
        # argument not usb
        return 1
    fi
}

vcs-diff-public () {
    # diff the "master" with the "public" branch for current directory or all child directories that are git repositories
    # XXXX: git only for now
    if [[ -d "${PWD}/.git" ]]; then
        git diff public..master
    else
        for dirname in ${PWD}/*; do
            if [[ -d "$dirname/.git" ]]; then
                pushd . >/dev/null
                cd "$dirname"
                if git rev-parse --verify public &>/dev/null; then
                    h1 "Checking $dirname"
                    git diff master..public --stat
                fi
                popd >/dev/null
            fi
        done
    fi
}

vcs-push-github () {
    # merge public branch and commit to github
    # XXXX: repository must be setup properly
    # TODO: update verions and commit
    # TODO: this probably only works because I use controlmaster
    #       second ssh to git@github.com does not work alone, the pipe makes it freeze
    ssh-batch -T git@github.com &>/dev/null
    if ! ssh-batch -T git@github.com 2>&1 | grep --color=never "success"; then
        yell "Error connecting to github! Aborting!"
        return 1
    fi
    if ! git -c color.ui=always checkout public; then
        yell "Checkout of public unsuccessful!"
        return 1
    fi
    # test the connection before doing any funny business
    # TODO: is this safe?
    git -c color.ui=always merge --squash -X theirs master --stat --allow-unrelated-histories
    local COMMITCORRECT=n
    while [[ "$COMMITCORRECT" != "y" ]]; do
        while read -r -t 0;do read -r; done
        read -e -p "Enter commit message: " COMMITMESSAGE
        # TODO: add option for quit
        while read -r -t 0;do read -r; done
        read -n 1 -p "Use commit message (y/n/q)? " COMMITCORRECT
        echo ""
        if [[ "$COMMITCORRECT" == "q" ]]; then
            yell "Aborting!"
            git -c color.ui=always checkout master
            return 1
        fi
    done
    git -c color.ui=always commit -a -m "$COMMITMESSAGE"
    # TODO: eventually go "public" locally to "master" globally
    git -c color.ui=always push --force --set-upstream github public:master
    git checkout master
}

vcs-conflicts () {
    # TODO: expand at some point
    git diff --name-only --diff-filter=U
}

ag-purge-all () {
    # purge all files related to uninstalled packages
    if dangerous-function-ask; then
        dpkg -l | grep ^rc | cut -d' ' -f3|xargs sudo dpkg --purge
    fi
}

git-serve () {
    # a convienient command to browse code for now
    git instaweb
}

harm-id3-audiobook-all () {
    # set up all audiobooks in immediate subdirectories for my player
    # (after appropriate file renaming)
    if dangerous-function-ask; then
        for d in ${PWD}/*; do
            [[ -d "$d" ]] || continue
            pushd . >/dev/null
            cd "$d"
            yes | harm-id3-genre-as-audiobook
            yes | harm-id3-album-as-directory
            yes | harm-id3-name-as-filename
            yes | harm-id3-alphabetical-track
            yes | harm-id3-remove-v1
            popd >/dev/null
        done
    fi
}

harm-id3-genre-as-audiobook () {
    # set genre of all .mp3 as audiobook
    if dangerous-function-ask; then
        eyeD3 --to-v2.4 --genre="Audiobook" *.mp3
    fi
}

harm-id3-name-as-filename () {
    # make track name correspond to filename
    if dangerous-function-ask; then
        for F in ${PWD}/*.mp3; do
            local BNAME="${f%%.mp3}"
            # XXXX: basename doesn't work with comma in filename
            local BNAME="${bname##*/}"
            eyeD3 --to-v2.4 --title="$BNAME" "$F"
        done
    fi
}

harm-id3-alphabetical-track () {
    # number tracks based on the alphabetical sort order
    if dangerous-function-ask; then
        # totals cause confusion
        eyeD3 --track-total=0 *.mp3
        local COUNT=1
        for F in ${PWD}/*.mp3; do
            eyeD3 --to-v2.4 --track=$(printf "%03d\n" $COUNT) "$F"
            let COUNT+=1
        done
    fi
}

harm-id3-album-as-directory () {
    # use directory name for album name as all tracks
    if dangerous-function-ask; then
        local ALBUM=$(basename "$PWD")
        eyeD3 --to-v2.4 --album "$ALBUM" *.mp3
    fi
}

harm-id3-remove-v1 () {
    # remove v1 id3 tags because they interfere with some players
    if dangerous-function-ask; then
        eyeD3 --remove-v1 *.mp3
    fi
}

ls-id3 () {
    # list id3 tags of all mp3s in directory
    eyeD3 *.mp3
}

ag-list-doc () {
    apt-cache search . | grep -- "\-doc " | cut -d' ' -f1
}

ag-list-packages-only () {
    ag-list-installed | cut -d' ' -f3
}


# the three-fingered claw, see https://stackoverflow.com/questions/1378274/in-a-bash-script-how-can-i-exit-the-entire-script-if-a-certain-condition-occurs
yell () {
    local NEWCOM=$(sed -r 's|'"$HOME"'|~|g' <<< "$0")
    echo -e "${BRed}$NEWCOM${Red}: $*${Color_Off}" >&2
}

die () {
    yell "$*"; exit 111
}

try () {
    "$@" || die "cannot $*"
}

warn () {
    # XXXX: not good because it starts up a new command, but avoids escaping slashes
    local NEWCOM=$(sed -r 's|'"$HOME"'|~|g' <<< "$0")
    echo -e "${BYellow}$NEWCOM${Yellow}: $*${Color_Off}" >&2
}

msg () {
    local NEWCOM=$(sed -r 's|'"$HOME"'|~|g' <<< "$0")
    echo -e "${BGreen}$NEWCOM${Green}: $*${Color_Off}" >&2
}

h1 () {
    if [[ -z "$*" ]]; then
        local OUTSTR=$(cut -c 1-80 <<< "================================================================================")
    else
        local OUTSTR=$(cut -c 1-80 <<< "==== $* ================================================================================")
    fi
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-end () {
    if [[ -z "$*" ]]; then
        local OUTSTR=$(cut -c 1-80 <<< "")
    else
        local OUTSTR=$(cut -c 1-80 <<< "$*")
    fi
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h1-script () {
    local OUTSTR=$(cut -c 1-80 <<< "==== Running $(basename $0) ================================================================================")
    echo -e "${BWhite}${On_Blue}$OUTSTR${Color_Off}" >&2
}

h1-script-end () {
    local OUTSTR=$(cut -c 1-80 <<< "Finishing $(basename $0)")
    echo -e "${BWhite}${On_Blue}<<<<${Color_Off} ${BWhite}$OUTSTR${Color_Off}" >&2
}

h2 () {
   if [[ -z "$*" ]]
    then
        local OUTSTR=$(cut -c 1-60 <<< "----------------------------------------")
    else
        local OUTSTR=$(cut -c 1-60 <<< "---- $* ----------------------------------------")
   fi
   # TODO: probably want different color than cyan
   echo -e "${BWhite}${On_Cyan}$OUTSTR${Color_Off}" >&2
}

h3 () {
   if [[ -z "$*" ]]
    then
        local OUTSTR=$(echo "----")
    else
        local OUTSTR=$(echo "---- $*")
    fi
    echo -e "${White}${On_Purple}$OUTSTR${Color_Off}" >&2
}

git-ls () {
    git ls-tree -r master --name-only
}

test-all-colors () {
    # http://askubuntu.com/questions/27314/script-to-display-all-terminal-colors
    for x in 0 1 4 5 7 8; do for i in `seq 30 37`; do for a in `seq 40 47`; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo ""
}

aloopback () {
    arecord -vv | sox -t wav - -t wav - highpass 300 | aplay
}

aloopback-high () {
    arecord -vv | sox -t wav - -t wav - highpass 300 | aplay
}

aloopback-low () {
    arecord -vv | sox -t wav - -t wav - lowpass 300 | aplay
}

vcs-init-full () {
    # TODO: check for files existing
    git init && git add * && git commit -a -m 'initial commit'
}

check-emacs-daemon () {
    ps -ef | grep -- '[e]macs --daemon' >/dev/null
    return $?
}

check-chromium () {
    ps -ef | grep '/usr/lib/chromium/[c]hromium' >/dev/null
    return $?
}

check-firefox () {
    ps -ef | grep '[f]irefox\|[i]ceweasel\|[p]alemoon' >/dev/null
    return $?
}

disk-info () {
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo smartctl -A "$1"
    fi
}

monitor-disks () {
    disk-info /dev/sda
    disk-info /dev/sdb
    disk-info /dev/sdc
    disk-info /dev/sdd
    disk-info /dev/sde
    disk-info /dev/sdf
}


disk-temp () {
    if [[ -b "$1" ]]; then
        h1
        msg "$1"
        sudo hddtemp "$1"
        sudo smartctl -A "$1" | grep -i temperature
    fi
}

monitor-disk-temp () {
    disk-temp /dev/sda
    disk-temp /dev/sdb
    disk-temp /dev/sdc
    disk-temp /dev/sdd
    disk-temp /dev/sde
    disk-temp /dev/sdf
}

monitor-disk-speed () {
    # https://www.webhostingtalk.com/showthread.php?t=906573
    # http://www.yasith.info/2010/01/how-to-check-hard-disk-performance-and.html
    sudo hdparm -tT /dev/"$1"
}

fix-permissive-permissions () {
    if [[ -e "$1" ]]; then
        chmod 755 "$1"
    fi
}

fix-permissive-permissions-recursive () {
    if [[ -d "$1" ]]; then
        chmod -R 755 "$1"
    fi
}

add-line-if-not-exist () {
    local THEFILE="$1"
    local NEWLINE="$2"
    # TODO: check grep input before running
    grep -q -F -- "$NEWLINE" "$THEFILE" || echo "$NEWLINE" >> "$THEFILE"
}

kill-blank-lines () {
    sed -n -e '/^\s*$/d' "$1"
}

screen-select () {
    # TODO: do I want letters instead???
    local SCREENSESSIONS=$(screen -ls | grep pts | cut -f1 -d"." | sed -e 's/^[[:space:]]*//g')
    if [[ -n "$SCREENSESSIONS" ]]; then
        #Set the field separator to new line
        IFS=$'\n'
        #Try to iterate over each line
        local count=1
        for item in $SCREENSESSIONS; do
            echo "$count) $item"
            local count=$(( $count + 1 ))
        done
        while read -r -t 0;do read -r; done
        read -n 1 -p "Enter the screen session: " SCREENSELECT
        echo ""
        screen -dr $(sed -n "${SCREENSELECT}"p <<< "${SCREENSESSIONS}")
    else
        false
    fi
}

sage-notebook () {
    # open a Sage notebook and browser securely on port 18080
    # XXXX: requires defining of ${PYTHON_NOTEBOOK_ROOT} before calling, do I want this for sage.... fix...
    # TODO: JUPYTER_NOTEBOOK_ROOT is forward-looking...
    if [[ -n "${JUPYTER_NOTEBOOK_ROOT}" ]]; then
        # TODO: do I still need this?
        bleachbit --overwrite --clean epiphany.* google_chrome.*
        local NBPATH="${JUPYTER_NOTEBOOK_ROOT}/sage-notebooks-$HOSTNAME.sagenb"
        mkdir -p "$NBPATH"
        # XXXX: grep to avoid just sage-notebook from scripts that might run this
        if ps -ef | grep '[s]rc/bin/sage-notebook' >/dev/null; then
            sage-notebook-browser
            return 255
        else
            # TODO: select firefox and chromium?
            SAGE_BROWSER="nohup firefox -P sagenotebook" sage --notebook=sagenb secure=True port=18080 automatic_login=True interface='' directory="$NBPATH"
            # SAGE_BROWSER="nohup chromium" sage --notebook=sagenb secure=True port=18080 automatic_login=True interface='' directory="$NBPATH"
            return 0
        fi
    else
        yell 'JUPYTER_NOTEBOOK_ROOT not defined!!!'
    fi
}

# TODO: support multiple browsers?
sage-notebook-browser () {
    # open just the browser for a running Sage notebook
    if false; then
        bleachbit --overwrite --clean google_chrome.*
        chromium https://localhost:18080/ &>/dev/null &
    else
        # TODO: shred firefox if not running
        (nohup firefox -P sagenotebook https://localhost:18080/ &>/dev/null &)
    fi
}

sage-jupyter-notebook () {
    # open an iPython notebook and browser using the Sage platorm on port 18888
    # TODO: need to control where goes
    # XXXX: requires defining of ${PYTHON_NOTEBOOK_ROOT} before calling
    if [[ -n "$JUPYTER_NOTEBOOK_ROOT" ]]; then
        bleachbit --overwrite --clean epiphany.* google_chrome.*
        # set a good directory for these
        local NBPATH="${JUPYTER_NOTEBOOK_ROOT}/sage-jupyter-projects"
        mkdir -p "$NBPATH"
        # TODO: subsitute for --deep-reload --automagic --secure --pprint depricated options
        if ps -ef | grep -- '--[n]otebook=jupyter' >/dev/null; then
            sage-jupyter-notebook-browser
        else
            sage --notebook=jupyter --notebook-dir="$NBPATH" --browser="firefox -P default" --port=18888
        fi
    else
        yell '$PYTHON_NOTEBOOK_ROOT not defined!!!'
    fi
}

# TODO: support multiple browsers?
sage-jupyter-notebook-browser () {
    # open just the browser for a running iPython notebook
    bleachbit --overwrite --clean epiphany.* google_chrome.*
    firefox -P default http://localhost:18888/
}

file-mimetype () {
    # quick way to get mimetype
    file --mime-type "$1"
}

ssh-scs () {
    # XXXX: this one autodetaches after exit from screen session
    ssh "$@" -t "bash --rcfile ~/.bash_library -li -c \"screen-select\""
    # XXXX: this one stays attached after exit from screen session
    # ssh "$@" -t "bash --rcfile ~/.bash_library -li -c \"screen-select;/bin/bash\""
}

# TODO: move these out

youtube-previous () {
    # global function to see previous video in youtube playlist
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if [[ -n "$line" ]] && xdotool search --class conkeror | grep -- "$line" >/dev/null; then
            xdotool windowfocus --sync "$line"
            xdotool windowactivate --sync "$line"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.1
            conkeror-batch -f youtube-previous
        fi
    done
    # TODO: very arbitrary, perhaps wait for something to return
    sleep 0.5
    xdotool windowactivate --sync "$CURRENTWINDOW"
}

youtube-next () {
    # global function to see previous video in youtube playlist
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if [[ -n "$line" ]] && xdotool search --class conkeror | grep -- "$line" >/dev/null; then
            xdotool windowfocus --sync "$line"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.1
            conkeror-batch -f youtube-next
        fi
    done
    # TODO: very arbitrary delay, perhaps wait for something to return
    sleep 0.5
    xdotool windowactivate --sync "$CURRENTWINDOW"
}

focus-emacs-window () {
    # TODO: do something a little nicer, maybe use xdotool
    wmctrl -x -a emacs.Emacs
}

################################################################################
## enumerate things like block devices

enumerate-physical-disks () {
    # find all physical disks
    # TODO: will likely need to be improved for all appropriate uses
    for d in /dev/sd*; do
        [[ -b "$d" && ! "$d" =~ .*[[:digit:]] ]] || continue
        echo "$d"
    done
}

enumerate-crypt-disks () {
    # find all decrypted block devices
    # TODO: will likely need to be improved for all appropriate uses
    for d in /dev/mapper/crypt--*; do
        [[ -b "$d" ]] || continue
        echo "$d"
    done
}

df-crypt-disks () {
    # get information on decrypted block devices
    df -h $(enumerate-crypt-disks)
}

smartctl-disks () {
    # check overall health of all disks
    for d in $(enumerate-physical-disks); do
        local SMARTOUTPUT=$(sudo smartctl -H "$d")
        if [[ $(($? & 1)) ]]; then
            echo -n "$d: "
            # XXXX: to use this in scripts I have to add smartctl to no password sudo files
            echo "$SMARTOUTPUT" | grep --color=never "overall-health"
        fi
    done
}

smartctl-disks-errors () {
    # check overall health of all disks
    # TODO: current powered up time
    for d in $(enumerate-physical-disks); do
        h2 "$d"
        local POWERONHOURS=$(sudo smartctl -A "$d" | grep Power_On_Hours)
        local SMARTOUTPUT=$(sudo smartctl --log=error "$d")
        if [[ $(($? & 1)) ]]; then
            echo -n "$d: "
            # XXXX: to use this in scripts I have to add smartctl to no password sudo files
            echo "$POWERONHOURS"
            echo "$SMARTOUTPUT"
        fi
    done
}

select-disk-uuid-usb () {
    # select a usb disk by UUID or alternately any other mounted drive
    # XXXX: doesn't work with more than 9 drives, but could be fixed
    # TODO: will I always want to do this with usb? do I want option to select non-usb like FUSE?
    local USBARRAY=()
    if [[ -n "$1" ]]; then
        if [[ -e /dev/disk/by-uuid/"$1" ]]; then
            if findmnt -nr -o target /dev/disk/by-uuid/"$1" >/dev/null; then
                MOUNTPOINT=$(findmnt -nr -o target /dev/disk/by-uuid/"$1")
                DEVICE=$(readlink -f /dev/disk/by-uuid/"$1")
                LABEL=$(lsblk --output label /dev/disk/by-uuid/"$1" | tail -n 1)
                printf "0) %-10s %-40s %-25s (default, mounted on $MOUNTPOINT)\n" "$DEVICE" "$1" "$LABEL" >&2
            else
                DEVICE=$(readlink -f /dev/disk/by-uuid/"$1")
                LABEL=$(lsblk --output label /dev/disk/by-uuid/"$1" | tail -n 1)
                printf "0) %-10s %-40s %-25s (default, not mounted)\n" "$DEVICE" "$1" "$LABEL" >&2
            fi
        else
            echo "0) $1 (default, not found)" >&2
        fi
    fi
    local count=1
    for d in /dev/disk/by-uuid/*; do
        [[ "$d" == "/dev/disk/by-uuid/$1" ]] && continue
        if /sbin/udevadm info --query=all --name=$(readlink -f $d) | grep 'ID_BUS=usb' >/dev/null; then
            if findmnt -nr -o target "$d" >/dev/null; then
                MOUNTPOINT=$(findmnt -nr -o target "$d")
                LABEL=$(lsblk --output label "$d" | tail -n 1)
                printf "$count) %-10s %-40s %-25s (mounted on $MOUNTPOINT)\n" "$(readlink -f $d)" "$(basename $d)" "$LABEL" >&2
            else
                LABEL=$(lsblk --output label "$d" | tail -n 1)
                printf "$count) %-10s %-40s %-25s (not mounted)\n" "$(readlink -f $d)" "$(basename $d)" "$LABEL" >&2
            fi
            local count=$(( $count + 1 ))
            USBARRAY+=("$d")
        fi
    done
    # echo "$count) Non-USB drive" >&2
    echo "-) Cancel" >&2
    while read -r -t 0;do read -r; done
    read -n 1 -p "Enter the USB drive: " USBSELECT >&2
    echo "" >&2
    if [[ $USBSELECT == "0" ]]; then
        echo /dev/disk/by-uuid/"$1"
        return 0
    fi
    if [[ $USBSELECT == "-" ]]; then
        echo "Canceled!" >&2
        return 1
    fi
    if ! [[ $USBSELECT =~ ^[0-9]$ ]] || (( $USBSELECT >= $count )); then
        return 1
    fi
    local USBSELECT=$(( $USBSELECT - 1 ))
    # TODO: keep ensuring only proper thing is every returned, avoid use of tail
    echo ${USBARRAY[$USBSELECT]}
    return 0
}

# TODO: helper function to query physical disk info.... but only works for unencrypted
# TODO: query only USB
# TODO: keep finding parent disk
# TODO: lsblk may be best, but this shows what is needed for select-disk-uuid-??? functions
select-disk-uuid-info () {
    # TODO: need columns
    echo "ID: "
    for d in /dev/disk/by-id/*; do
        echo "$d: $(readlink -f $d) $(/sbin/udevadm info --query=all --name=$(readlink -f $d) | grep ID_BUS)"
    done
    echo ""
    echo "UUID: "
    for d in /dev/disk/by-uuid/*; do
        echo "$d: $(readlink -f $d) $(/sbin/udevadm info --query=all --name=$(readlink -f $d) | grep ID_BUS)"
    done
}

dangerous-function-ask () {
    if ask_yn "Dangerous function! Continue"; then
        true
    else
        false
    fi
}

continue-ask () {
    if ask_yn "Continue"; then
        true
    else
        false
    fi
}

vcs-grep-conflicted () {
    # find git conflicted markers in current directory tree
    # TODO: proper return values?
    # TODO: avoid running /home or above... takes way too long!
    find . -not -path "*.git*" -type f -exec grep -nH --color -- "^<<<<<<< \|^>>>>>>> \|^=======$\|^####### " {} \;
}

# TODO: broken, rfigure out if I can remove
# flashplayer-update () {
#     sudo update-flashplugin-nonfree --install --verbose
# }

mdstat-status () {
    local MDSTAT=$(cat /proc/mdstat | sed -n '/^md\|^[[:space:]]*\[\|blocks/p')
    local FIRST=1
    IFS=$'\n'
    for i in $(echo "$MDSTAT"); do
        if [[ "$i" =~ ^m.* ]]; then
            printf "$i"
        else
            local SELECTED=$(grep --color=never -Eo -- "\[[A-Za-z]*\]$" <<< "$i")
            if [[ -n "$SELECTED" ]]; then
                echo " $SELECTED"
            fi
        fi
    done
}

repl-restartable () {
    # restart a repl over and over again if desired
    local TRYAGAIN=" "
    while [[ "$TRYAGAIN" == " " ]]; do
        ($@)
        local RETURNVALUE=$?
        echo "repl-restartable return code: $RETURNVALUE"
        if [[ "$RETURNVALUE" == 255 ]]; then
            # TODO: better return values than this?
            return 255
        fi
        while read -r -t 0;do read -r; done
        IFS= read -n 1 -s -p 'Press [Enter] to exit or [Space] to restart...' TRYAGAIN
        if [[ "$TRYAGAIN" == " " ]]; then
            reset
        fi
    done
    return 0
}

vcs-attr () {
    # https://stackoverflow.com/questions/6855712/why-does-git-treat-this-text-file-as-a-binary-file
    # check attributes
    git check-attr --all -- "$1"
}

################################################################################
## genric download for Canada NTS topo maps
## good scripts for slurping data from other ftp websites

wget-download-canmatrix2-doc () {
    local NEWDIR="/mnt-secondary/"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=300 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/doc/
    popd >/dev/null
}

wget-download-canmatrix2-50k-preview () {
    local NEWDIR="/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    popd >/dev/null
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/50k/
}

wget-download-canmatrix2-250k-preview () {
    local NEWDIR="/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    popd >/dev/null
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --restrict-file-names=unix \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/250k/
}

wget-download-canmatrix2 () {
    local NEWDIR="/mnt-secondary"
    mkdir -p "$NEWDIR"
    pushd . >/dev/null
    cd "$NEWDIR"
    # TODO: need an alias for this type of download
    wget \
      --execute robots=off \
      --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36" \
      --recursive \
      --no-parent \
      --level=inf \
      --random-wait \
      --continue \
      --limit-rate=300k \
      --wait=600 \
      --waitretry=60 \
      "$1"
    popd >/dev/null
}

# TODO: this can be a lot better at some point
wget-current-canmatrix () {
    # expect to take about 16*((16 * 12) + 60) per large grid = 4032min per large numbered grid
    # generally run this on my server to an external hard drive at ~/mnt
    local URLS=("ftp://ftp2.cits.rncan.gc.ca/pub/canmatrix2/50k_tif/104/p")
    if ! type send-returncode-mail >/dev/null; then
        warn "No text message progress reports, send-returncode-mail function not configured."
        alias send-returncode-mail="false"
    else
        true
        send-returncode-mail "Canmatrix- starting!"
    fi
    if mountpoint -q /mnt-secondary; then
        {
            time {
                pushd . >/dev/null
                cd /mnt-secondary
                # 83 urls, area around edmonton
                h1 "Starting!!!"
                for URL in "${URLS[@]}"; do
                    h2 "Next!!!"
                    h3 "$URL"
                    wget-download-canmatrix2 "$URL"
                    # TODO: fix this, probably by aliasing send-returncode-mail to false if not exist
                    send-returncode-mail "Canmatrix- done another grid!" "$URL"
                    sleep $(( $RANDOM % 60 + 30 ))m
                    # test code
                    # echo "$URL"
                    # sleep $(( $RANDOM % 60 + 30 ))s
                done
                popd >/dev/null
            }
        } 2>&1 | tee -a /mnt-secondary/canmatrix2-$(date-time-stamp).log
        send-returncode-mail "Canmatrix- done grid script!"
    else
        yell "Nothing mounted to collect data!!!"
    fi
}

add-timestamp-head-of-all-files () {
    for f in ${PWD}/*; do
        [[ -f "$f" ]] || continue
        [[ ! "$(basename $f)" =~ [0-9]{14}--.* ]] || continue
        echo "Moving $(basename $f)"
        mv "$(basename $f)" "$(stat $(basename $f) | grep Modify: | sed -e 's/Modify: //' | sed -e 's/-//g' | sed -e 's/://g' | sed -e 's/\..*//g' | sed -e 's/ //g')--$(basename $f)"
    done
}

read-mail () {
    less /var/spool/mail/${USERNAME}
}

gpg-decrypt () {
    gpg-batch --decrypt "$1" 2>/dev/null
}

svg2png-hq () {
    if [[ -z "$1" ]]; then
        yell "No input!"
        return 1
    fi
    local OUTPUT="${1%%.svg}.png"
    if [[ -f "$OUTPUT" ]]; then
        yell "Output $OUTPUT already exists!!!"
        return 1
    else
        convert -density 300 -resize 2000x "$1" "$OUTPUT"
    fi
}

function ls-cron () {
    crontab -u "$USERNAME" -l
}

function ag-rdep () {
    apt-cache rdepends "$1"
}

function ag-rdep-installed () {
    apt-cache rdepends "$1" --installed
}

function ls-mime-files () {
    # list mime settings
    # https://wiki.archlinux.org/index.php/default_applications
    local THEFILES=("$HOME/.config/$desktop-mimeapps.list" "$HOME/.config/mimeapps.list" "/etc/xdg/mimeapps.list" "$HOME/.local/share/applications/mimeapps.list" "/usr/local/share/applications/mimeapps.list" "/usr/share/applications/mimeapps.list")
    for f in ${THEFILES[@]}; do
        if [[ -e "$f" ]]; then
            h3 "$f"
            cat "$f"
        else
            warn "$f not exist!"
        fi
    done

}

function ls-mime-files2 () {
    # see https://unix.stackexchange.com/questions/36380/how-to-properly-and-easy-configure-xdg-open-without-any-enviroment
    # XXXX: changed variable from dd, bad name for bash variable
    for thedir in /usr/share/applications $HOME/.local/share/applications; do
        h2 "$thedir"
        for thefile in $(ls $thedir 2>/dev/null | grep "\\.desktop$"); do
            h3 "$thefile"
            for m in $(grep MimeType $thedir/$thefile | cut -d= -f2 | tr ";" " "); do
                echo xdg-mime default $thefile $m
            done
        done
    done
}

caps-toggle () {
    # toggle caps just in case
    xdotool key Caps_Lock
}

view-mail () {
    tail -n 200 /var/spool/mail/${USERNAME}
}

srvg () {
    if [[ -z "$1" ]]; then
        service --status-all
    else
        service --status-all | grep -- "$1"
    fi
}

srvr () {
    sudo service "$1" restart
}

srvs () {
    sudo service "$1" status
}

flatten-current-directory () {
    if [[ $@ != *"--for-real"* ]]; then
        find . -mindepth 2 -type f -exec mv {} .
    else
        yell "Dangerous function!!! Use --for-real!!!"
    fi
}

dunst-notifications () {
    printf "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    grep "summary: \|body: " "$HOME/tmp/dunst-current.log" | grep -v \'\' | sed -e 's/^[ \t]*//' | sed -e 's/body: /    /' | sed -e 's/summary: //'
}

ag-list-explicitly-installed () {
    aptitude search '~i !~M'
}

show-all-x-displays () {
    # https://unix.stackexchange.com/questions/17255/is-there-a-command-to-list-all-open-displays-on-a-machine
    cd /tmp/.X11-unix && for x in X*; do echo ":${x#X}"; done
}

phoronix-describe-all-tests () {
    (IFS=$'\n'
     for testline in $(\phoronix-test-suite list-available-tests | tail -n +5 | head -n -2); do
         h2 $(awk '{ print $1 }' <<< "$testline")
         \phoronix-test-suite info $(awk '{ print $1 }' <<< "$testline")
     done)
}

inhibit-powersave () {
    # make sure screensaver does not restart
    # TODO: inhibit power management too
    # TODO: if I can blow out of loop and reenable screensaver?
    # TODO: power up all...
    while true; do
        echo "Trying..."
        xscreensaver-command -exit
        # https://bbs.archlinux.org/viewtopic.php?id=134289
        screensaver-builtin-disable
        cpu-throttle-up
        sleep 15
    done
}

inhibit-tty-powersave () {
    setterm -blank 0 -powersave off
}

screensaver-disable () {
    xscreensaver-command -exit
    xset s 0 0 s noblank
    xset s off
    xset dpms 0 0 0
    xset -dpms
}

screensaver-enable () {
    (nohup xscreensaver -nosplash &>/dev/null &)
    xset s 0 0 s noblank
    xset s off
    xset dpms 0 0 0
    xset -dpms
}

screensaver-builtin-only () {
    xscreensaver-command -exit
    xset s 0 0 s noblank
    xset s off
    xset dpms 0 0 0
    xset -dpms
}

grep-commands () {
    h1 'Commands in $PATH'
    printf '%s\n' ${PATH//:/\/* } | grep -- "$1"
    h1 "Bash functions"
    declare -F | grep -- "$1"
    h1 "Aliases"
    alias | grep -- "$1"
}

rsync-remove-source () {
    # TODO: better interace
    # TODO: still put right picket fence
    # if [[ ! -d "$1" ]]; then
    #     yell "Empty arguments!"
    #     return 1
    # fi
    # TODO: check here!
    if ssh "$1" true; then
        msg "Incoming from $1"
        local BACKUPDIR="rsync-backups-${1}-$(date-time-stamp)"
        rsync --progress --archive --checksum --backup --backup-dir="$BACKUPDIR" --rsh='ssh' --remove-source-files "${1}:${2}/" .
        # will cause error if there are backups
        rmdir --ignore-fail-on-non-empty "$BACKUPDIR"
    else
        warn "Hostname $1 not found!"
    fi
}

rsync-check-source () {
    # do this before running above with same arguments
    if ssh "$1" true; then
        # TODO: make explicitly that contents of that directory come into current directory
        rsync --verbose --checksum --progress --archive  --rsh='ssh' "${1}:${2}/" .
    else
        warn "Hostname $1 not found!"
    fi
}

vcs-incoming () {
    # https://stackoverflow.com/questions/1331385/how-can-i-see-incoming-commits-in-git
    # do not do above anymore
    # https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch
    h2 "The log: "
    # TODO: configure a little better, want to see on screen and not wierd pager stuff
    git log --decorate=full --graph --stat ..origin/"$(git rev-parse --abbrev-ref HEAD)"
    read -n 1 -s -r -p "Press any key to continue... "
    echo ""
    h2 "The diffs: "
    git diff --stat @{upstream}
    git diff @{upstream}
}

vcs-reset () {
    # dangerous command, check first
    # TODO: often used to reset and pull
    if dangerous-function-ask; then
        git reset --hard HEAD
    fi
}

trim-mp3-to-30min-skip-first-30s () {
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 00:30:00 "$2"
}

trim-mp3-to-30min () {
    ffmpeg -i "$1" -codec copy -ss 00:00:00 -t 00:30:00 "$2"
}

trim-mp3-to-1hr-skip-first-30s () {
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 01:00:00 "$2"
}

trim-mp3-to-1hr () {
    ffmpeg -i "$1" -codec copy -ss 00:00:00 -t 01:00:00 "$2"
}

trim-mp3-to-2hr-skip-first-30s () {
    # this is a good function to trim long playing music that has an unwanted intro
    ffmpeg -i "$1" -codec copy -ss 00:00:30 -t 02:00:00 "$2"
}

trim-mp3-to-2hr () {
    ffmpeg -i "$1" -codec copy -ss 00:00:00 -t 02:00:00 "$2"
}

normalize-volume () {
    # set system volume to nice levels on one run
    amixer set Master 50%
    amixer set Master unmute
    # youtube volume sometimes stupid, normalize it too
    youtube-normalize-volume
    local DATESTAMP=$(date-time-stamp)
    notify-send "Normalizing volume" "$DATESTAMP" -t 5000
}

youtube-normalize-volume () {
    # global function to normalize volume in youtube windows
    # TODO: if no window here
    local CURRENTWINDOW=$(xdotool getwindowfocus)
    xdotool search --name youtube | while IFS= read -r line; do
        if [[ -n "$line" ]] && xdotool search --class conkeror | grep -- "$line" >/dev/null; then
            xdotool windowfocus --sync "$line"
            xdotool windowactivate --sync "$line"
            # TODO: very arbitrary delay, perhaps wait for something to return
            sleep 0.05
            conkeror-batch -f youtube-normalize-volume
        fi
    done
    # TODO: very arbitrary, perhaps wait for something to return
    sleep 0.05
    xdotool windowactivate --sync "$CURRENTWINDOW"
}

alias ffn='find-iname'
find-iname () {
    # TODO: need alias for this
    find . -iname '*'"$1"'*'
}

xset-query () {
    xset -q
}

grep-gz-files () {
    # only elisp for now
    find -name "*.el.gz" -print0 | xargs -0 zgrep "$1"
}

strip-leading-trailing-chars () {
    # strip leading and trail characters I do not want for many applications
    # TODO: keep adding more as I need them
    # TODO: make work with more things
    read string
    echo "$string" | sed 's/^[-]*//' | sed 's/[-]*$//'
}

gpg-batch () {
    gpg2 --no-verbose --quiet --batch --yes "$@"
}


android-screenshot-all () {
    pushd . >/dev/null
    cd "$HOME"
    # TODO: better name...
    local FNAME=android-screen-$(date-time-stamp).png
    adb shell screencap -p /sdcard/"$FNAME"
    adb pull /sdcard/"$FNAME"
    adb shell rm /sdcard/"$FNAME"
    popd >/dev/null
}

android-record-all () {
    # TODO: specify time limit better
    pushd . >/dev/null
    cd "$HOME"
    local FNAME=android-screenrecord-$(date-time-stamp).mp4
    adb shell screenrecord --verbose --time-limit 180 /sdcard/"$FNAME"
    adb pull /sdcard/"$FNAME"
    adb shell rm /sdcard/"$FNAME"
    popd >/dev/null
}

harm-fonts () {
    sudo dpkg-reconfigure fontconfig
    # TODO: sudo? not yet, make sure this is necessary?
    # fc-cache -f -v
}

benchmark-compression-gzip () {
    # benchmark gzip compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tgz)
    time {
        tar --create --file - "$1" | gzip -1 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized!
        gzip -d "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-bzip2 () {
    # benchmark bzip2 compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.bz2)
    time {
        tar --create --file - "$1" | bzip2 -9 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized!
        bzip2 -d "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-lz4 () {
    # benchmark lz4 compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.lz4)
    time {
        tar --create --file - "$1" | lz4 -1 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized!
        lz4 -d "$THETEMPFILE" &>/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-lzop () {
    # benchmark lzop compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.lzop)
    time {
        tar --create --file - "$1" | lzop -6 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized!
        lzop -d -c "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-lzop-here () {
    # benchmark lzop compression
    du -sh "$1"
    # TODO: share with above
    local THETEMPFILE=$(mktemp "./tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.lzop)
    time {
        tar --create --file - "$1" | lzop -6 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized!
        lzop -d -c "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-rzip () {
    # benchmark rzip compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --dry-run --suffix=.tar.rz)
    time {
        tar --create --file - "$1" > test.tar
        rzip -3 test.tar -o "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        rzip -d "$THETEMPFILE"
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

# TODO: will not work on directories for now
# TODO: do later
# benchmark-compression-lrzip () {
#     # benchmark lzip compression
#     du -sh "$1"
#     local THETEMPFILE=$(mktemp tmp-benchmark-compression-XXXXXXXXXX --dry-run --suffix=.tar.lrzip)
#     time {
#         lrzip --level 9 "$1" --outfile "$THETEMPFILE"
#     }
#     echo ""
#     du -sh "$THETEMPFILE"
#     time {
#         # XXXX: hope this is not optimized away!
#         lrzip -d "$THETEMPFILE" --outfile /dev/null
#     }
#     sleep 2
#     rm "$THETEMPFILE"
# }

benchmark-compression-lzip () {
    # benchmark lzip compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.lzip)
    time {
        tar --create --file - "$1" | lzip -9 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized away!
        lzip -d -c "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-xz () {
    # benchmark lz compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --suffix=.tar.xz)
    time {
        tar --create --file - "$1" | xz -9 > "$THETEMPFILE"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized!
        xz -d "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "${THETEMPFILE%%.*}".tar ]] && rm "${THETEMPFILE%%.*}".tar
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-zip () {
    # benchmark lz compression
    mkdir -p "$HOME/tmp"
    du -sh "$1"
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-benchmark-compression-XXXXXXXXXX" --dry-run --suffix=.zip)
    time {
        zip "$THETEMPFILE" "$1"
    }
    echo ""
    du -sh "$THETEMPFILE"
    time {
        # XXXX: hope this is not optimized!
        unzip -p "$THETEMPFILE" >/dev/null
    }
    sleep 2
    [[ -f "$THETEMPFILE" ]] && rm "$THETEMPFILE"
}

benchmark-compression-all () {
    # benchmark all supported compression methods
    h2 "gzip"
    benchmark-compression-gzip "$1"
    h2 "bzip2"
    benchmark-compression-bzip2 "$1"
    h2 "lz4"
    benchmark-compression-lz4 "$1"
    h2 "lzop"
    benchmark-compression-lzop "$1"
    h2 "lzip"
    benchmark-compression-lzip "$1"
    h2 "rzip"
    benchmark-compression-rzip "$1"
    h2 "xz"
    benchmark-compression-xz "$1"
    h2 "zip"
    benchmark-compression-zip "$1"
}

pdftk-cat () {
    if [[ -z "$1" ]]; then
        echo "pdftk-cat <<pdf basename to create>>"
    else
        # create pdf from alphabetically-order pdfs in current directory, using pdftk
        pdftk *.pdf cat output "$1".pdf
    fi
}

pdftk-split () {
    if [[ -z "$1" ]]; then
        echo "pdftk-split <<pdf filename in>> <<start page>> <<end page>>" "<<pdf filename out>>"
        echo "Use page numbering and not page naming."
    else
        # create pdf from alphabetically-order pdfs in current directory, using pdftk
        pdftk "$1" cat "$2"-"$3" output "$4"
    fi
}

alias cdf="cd-first"
cd-first () {
    # go to the first matching pattern
    local FIRST=$(ls --color=never -dtr1 "$1"* | head -1)
    cd "$FIRST"
}
alias lsf="ls-first"
ls-first () {
    # go to the first matching pattern
    local FIRST=$(ls --color=never -dtr1 "$1"* | head -1)
    ls "$FIRST"
}

alias cdl="cd-latest"
cd-latest () {
    # go to the lastest matching pattern
    local LATEST=$(ls --color=never -dtr1 "$1"* | tail -1)
    cd "$LATEST"
}
alias lsl="ls-latest"
ls-latest () {
    # go to the lastest matching pattern
    local LATEST=$(ls --color=never -dtr1 "$1"* | tail -1)
    ls "$LATEST"
}

list-x11-displays () {
    pushd . >/dev/null
    cd /tmp/.X11-unix
    for x in X*; do
        echo ":${x#X}"
    done
    popd >/dev/null
}

screen-list-all-session-commands () {
    # based on
    SCREEN_SESSIONS=( $(screen -ls | grep pts | cut -f1 -d"." | sed -e 's/^[[:space:]]*//g') )
    for SCREEN_SESSION_PID in "${SCREEN_SESSIONS[@]}";do
        h2 "Screen session pid: $SCREEN_SESSION_PID"
        screen -ls "$SCREEN_SESSION_PID"
        # TODO: will all screens have bash base
        SCREEN_CHILD=$(ps -el | grep -- $(ps -el | grep "$SCREEN_SESSION_PID" | grep bash | awk '{print $4}') | grep -v bash | awk '{print $4}')
        if [[ -n "$SCREEN_CHILD" ]]; then
            echo $(ps u -p "$SCREEN_CHILD") | fold -w 160
        else
            warn "No non-bash child process!"
        fi
    done
}
# TODO: do I want scl to always do this?
alias scl-commands="screen-list-all-session-commands"

ag-sizes () {
    # get sorted sizes of packages installed
    dpkg-query -Wf '${Installed-Size}\t${Package}\n' | sort --numeric -
}

# TODO: this is temporary, means I am forced to use sc, eventually want screen to just do this
screen-default () {
    if [[ -z "$1" || ! "$1" =~ ^- ]]; then
        yell "Default screen must have options associated with it! Use sc command to start screen instead!"
        return 1
    fi
    \screen "$@"
}
alias screen='screen-default'

screen-name () {
    if [[ -z "$1" ]]; then
        yell "Must specify screen session name!!!"
        return 1
    fi
    local SCREEN_SESSION="$1"
    shift
    screen -S "$SCREEN_SESSION" "$@"
}
alias sc='screen-name'

find-newest-modified () {
    # find . -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head
    find . -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d: -f2- | head -n 20
}

tar-to-here () {
    tar cvzf ./"$2".tgz "$1"
}

# https://stackoverflow.com/questions/26621647/convert-human-readable-to-bytes-in-bash
dehumanise() {
  for v in "$@"; do
    echo $v | awk \
      'BEGIN{IGNORECASE = 1}
       function printpower(n,b,p) {printf "%u\n", n*b^p; next}
       /[0-9]$/{print $1;next};
       /K(iB)?$/{printpower($1,  2, 10)};
       /M(iB)?$/{printpower($1,  2, 20)};
       /G(iB)?$/{printpower($1,  2, 30)};
       /T(iB)?$/{printpower($1,  2, 40)};
       /KB$/{    printpower($1, 10,  3)};
       /MB$/{    printpower($1, 10,  6)};
       /GB$/{    printpower($1, 10,  9)};
       /TB$/{    printpower($1, 10, 12)}'
  done
}

vcs-change-remote () {
    # no arguments just gives remotes
    if [[ -z "$1" ]];then
        git remote -v
    else
        git remote set-url "$1" "$2"
    fi
}

WGETOKCODES="200 OK\|302 Found"
WGETERRORCODES="301 Moved Permanently\|404 Not Found\|406 Not Acceptable\|503 Service Unavailable\|504 Gateway Time-out\|Read error\|416 Requested Range Not Satisfiable\|300 Multiple Choices\|500 Internal Server Error\|^Error\|^Retrying\|^Giving\|Data connection: Connection timed out"

wget-check-log-unknown-codes () {
    # TODO: find things that are not these, so I can start catologuing good errors
    # TODO: see if I can identify fatal errors
    grep -Hn -- "awaiting response" "$1" | grep -v -- "$WGETOKCODES"  | grep -v -- "$WGETERRORCODES"
    # TODO: more informative return code?
    return 0
}

wget-check-log () {
    # TODO: find things that are not these, so I can start catologuing good errors
    # TODO: can I search in a grep function
    h1 "Error codes"
    grep --color=always -Hn -B 2 -A 4 -- "$WGETERRORCODES" "$1"
    h1 "Unknown codes"
    wget-check-log-unknown-codes "$1"
}

als () {
    # archive ls
    # TODO: add help for command to use
    if [[ "$1" == *.tar* || "$1" == *.tgz ]]; then
        tar-ls "$1"
    elif [[ "$1" == *.zip ]]; then
        unzip -l "$1"
    elif [[ "$1" == *.rar ]]; then
        unrar l "$1"
    fi
}

# TODO: combine with above?
tar-ls () {
    if [[ "$1" == *.tar.gz || "$1" == *.tgz ]]; then
        tar -ztf "$1"
    else
        tar -tf "$1"
    fi
}

ls-grep () {
    # a simple function for simple searches of a directory
    ls --color=always -1 | grep --color=always -i -- "$1"

}
alias grep-ls="ls-grep"

grep-less () {
    grep --color=always -Ri $@ | less -r
}
alias less-grep="grep-less"

sqlite-cat () {
    sqlite3 "$1" .dump | less
}
alias cat-sqlite="sqlite-cat"

unzip-all () {
    for F in ./*.zip; do
        mkdir -p "${F}.d"
        pushd . >/dev/null
        cd "${F}.d"
        unzip ../"$F"
        popd >/dev/null
    done
}

unzip-in-path () {
    if [[ -n "$1" ]] || [[ -f "$1" ]]; then
        mkdir -p "${1}.d"
        cd "${1}.d"
        unzip ../"$1"
    else
        yell "Does not exist or is not a file!"
    fi
}


unzip-ls () {
    # TODO: check if zip is not here
    for F in ./*.zip; do
        h2 "$F"
        unzip -l "$F"
    done
}


# TODO: are these enough patterns?
grep-ri () {
    grep --color=always -Ri "$@" . | grep -v "\\.git/" | less -R
}

less-highlight () {
    # slight delay....
    if [[ -z "$1" ]]; then
        echo "A filename is required for less-pyg!"
    elif [[ -e "$1" ]]; then
        pygmentize -O style=native -g -f terminal256 "$1" | less --IGNORE-CASE --LONG-PROMPT --RAW-CONTROL-CHARS +Gg
    else
        echo "File $1 does does not exist!"
    fi
}
alias lh='less-highlight'

less-sh () {
    # faster... but looks terrible by default
    # TODO: fix colors on this
    /usr/share/source-highlight/src-hilite-lesspipe.sh "$1" | less
}

count-nondot-files () {
    find . -type f -not -path '*/\.*' | wc -l
}

geotiff-info () {
    for F in $@; do
        [[ "$F" =~ "tif" ]] || continue
        h2 "$F"
        gdalinfo "$F"
    done
}

check-git-repo () {
    [[ -d .git ]] || git rev-parse --git-dir &>/dev/null
}

ag-reinstall-all () {
    if dangerous-function-ask; then
        sudo dpkg --get-selections > "$HOME/list.log"
        for i in $(cat list.log); do sudo apt-get install --reinstall "$i"; done
    fi
}

ag-reinstall-dependent () {
    if [[ -n "$1" ]]; then
        if dangerous-function-ask; then
            # https://askubuntu.com/questions/275719/reinstall-package-and-its-installed-dependencies
            sudo apt-cache depends "$1" | grep '[ |]Depends: [^<]' | cut -d: -f2 | tr -d ' ' | xargs sudo apt-get --reinstall install -y
        fi
    fi
}

check-permissions-rw () {
    # find files I do not own
    h3 "Files not owned or in my group"
    find . ! -user "$USER"
    h3 "Directories I do not have sufficient privileges for"
    # TODO: exclude .git
    find . -type d -user "$USER" ! -perm -700
    h3 "Files I do not have sufficient privileges for"
    # TODO: exclude .git
    find . -user "$USER" ! -perm -600
}

ls-sqlite-tables () {
    sqlite3 "$1" '.tables'
}

cat-all () {
    for F in ./*; do
        h1 "$F"
        cat "$F"
    done
}

ask_yn () {
    local YN=
    while [[ "$YN" != 'y' && "$YN" != 'n' ]]; do
        while read -r -t 0;do read -r; done
        read -n 1 -p "$1 (y/n)? " YN
        echo ""
    done
    if [[ "$YN" == 'y' ]]; then
        return 0
    elif [[ "$YN" == 'n' ]]; then
        return 1
    fi
}

convert-size-to-bytes () {
    # convert a size with units (K,M,G) to bytes
    # use 1000 for kB MB GB
    # TODO: deal with trailing B
    # TODO: expand to terabyte and petabyte
    echo "$1" | sed 's/G/ * 1000 M/;s/M/ * 1000 K/;s/K/ * 1000/; s/$/ +\\/; $a0' | bc
}

convert-size-to-bytes-1024 () {
    # convert a size with units (K,M,G) to bytes
    # use 1024 for kiB MiB GiB
    # TODO: expand to terabyte and petabyte
    # TODO: deal with trailing B
    echo "$1" | sed 's/G/ * 1024 M/;s/M/ * 1024 K/;s/K/ * 1024/; s/$/ +\\/; $a0' | bc
}

tar-bzip2-remove () {
    # this tars then bzips a directory and then removes the original directory
    # TODO: dangerous, I have some checks but needs more
    # XXXX: it uses $HOME/tmp as temp directory because that has often more space than /tmp on my machines
    # make sure there are no errors except sockets
    # make sure source exists and destination does not
    echo "----------------------------------------"
    if [[ -n "$3" ]]; then
        echo "Too many arguments!"
    fi
    echo "Dangerous function! Sleeping for 10s!"
    sleep 10
    mkdir -p "$HOME/tmp"
    if [[ ! -d "$1" ]]; then
        echo "Directory $1 must exist!"
        return 1
    fi
    if [[ -e "$2" ]]; then
        echo "Destination $2 must not exist!"
        return 1
    fi
    local INFULLPATH=$(readlink -f "$1")
    local OUTFULLPATH=$(readlink -f "$2")
    # TODO: quit if readlink fails?
    local INSIZE=$(du -sh "$1")
    if [[ "$OUTFULLPATH" == "$INFULLPATH"/ ]]; then
        echo "$OUTFULLPATH must not be contained in $INFULLPATH!"
        return 1
    fi
    if [[ "$INFULLPATH" != "$HOME"/?*/?* ]];then
        echo "$INFULLPATH must be contained in a top level directory of $HOME!"
        return 1
    fi
    if [[ "$OUTFULLPATH" != "$HOME"/?*/?* ]];then
        echo "$OUTFULLPATH must be contained in a top level directory of $HOME!"
        return 1
    fi
    # check if successful, need temp files
    # https://stackoverflow.com/questions/1550933/catching-error-codes-in-a-shell-pipe
    local THETEMPFILE=$(mktemp "$HOME/tmp/tmp-bzip-remove-XXXXXXXXXX" --suffix=.tar)
    echo "Tarring $1 to $THETEMPFILE..."
    time {
        tar --create --file - "$1" > "$THETEMPFILE"
    }
    if [[ $? != 0 ]]; then
        echo "Error creating $1 while creating $THETEMPFILE!"
        [[ -e "$THETEMPFILE" ]] && rm "$THETEMPFILE"
        return 1
    fi
    echo "Compressing $THETEMPFILE to $2..."
    time {
        bzip2 --stdout -9 "$THETEMPFILE" > "$2"
    }
    if [[ $? != 0 ]];then
        echo "Error during compression!"
        [[ -e "$THETEMPFILE" ]] && rm "$THETEMPFILE"
        return 1
    fi
    [[ -e "$THETEMPFILE" ]] && rm "$THETEMPFILE"
    local OUTSIZE=$(du -sh "$2")
    echo "Size reduced from $INSIZE to $OUTSIZE."
    echo "Creating $2 from $1 successful!"
    echo "Deleting $1 in 10s!"
    sleep 10
    rm -rf "$1"
}

# https://unix.stackexchange.com/questions/17255/is-there-a-command-to-list-all-open-displays-on-a-machine
x11-all-displays () {
    pushd . >/dev/null
    cd /tmp/.X11-unix
    for x in X*; do
        echo ":${x#X}"
        # TODO: do a bit better with multiple ones later
        popd >/dev/null
        return
    done
    popd >/dev/null
}

ssh-check-host () {
    if [[ -z "$1" ]];then
        return 1
    fi
    nc -z "$1" 22 >/dev/null
}

ssh-check-host-verbose () {
    if [[ -z "$1" ]];then
        warn "Must specify host!"
        return 1
    fi
    nc -z -v "$1" 22
}
